<!-- TOC -->

- [宏定义](#宏定义)
- [预定义宏](#预定义宏)
    - [预定义宏](#预定义宏-1)
    - [环境宏](#环境宏)
- [头文件](#头文件)

<!-- /TOC -->

C 语言编译器前端还分为预处理阶段与编译阶段。预处理阶段是通过 C 语言的各类预处理器将指定的一些字符符号直接替换到即将编译的源代码。预处理器在跨平台整合上很有帮助，我们一般可以利用预处理器针对有差异的系统平台安插不同的源代码。

用于预处理的指示符称为**预处理指示符（preprocessing directives）**，C 语言主要有三大类预处理指示符 —— **条件段（if-section）预处理指示符**、**控制行（control-line）预处理指示符**、**空指示符（null directive）**。将会为大家介绍条件预处理、文件包含、宏替换、行控制、错误指示符、编译指示（pragma）指示符、空指示符以及C11标准中预定义的宏名。

对于任意一条预处理指示符，除了 `_Pragma` 之外，其他的都必须是以 # 符号打头，并且 # 符号必须出现在每一行的最前面。也就是说，如果我们要在源文件中某一行使用一条预处理指示符，那么最开头就得写上 #，前面除了空白符之外不允许出现其他任何字符。一条预处理指示符的最后都无需加分号。对于预处理组（比如条件段预处理指示符）而言，其作用范围从组的起始指示符开始的下一行一直到该组结束指示符的上一行。对于控制行预处理器指示符（比如宏定义）而言，一行就定义了某个符号或执行某个动作，它们不作用到下一行。

# 宏定义

宏定义属于控制行预处理指示符。以 `#define` 定义的一个符号称为**宏（macro）**。这里，# 与 define 之间可以存在空白符（换行符除外），但对于某些 C 代码编辑器而言，一旦 # 与 define 之间存在空白符，可能会导致编辑器在词法上无法识别，从而无法获得该有的语法高亮。因此建议各位在用以 # 打头的任何预处理指示符的时候，# 与跟在它后面的指示符之间不要有任何空白符。

在 C 语言中，宏的定义有两种形式，一种是类似对象的宏定义，另一种是类似函数的宏定义。类似对象的宏定义的形式为：

```c
#define 标识符 替换列表可省 换行符
```

类似函数的宏定义形式为：

```c
#define 标识符(参数列表) 替换列表可省 换行符
```

```c
#include <stdio.h>

// 编译时期 被替换
#define sum(a, b) ((a)+(b))

int main(void)
{
    printf("%d\n", sum(1, 2)); // ((1)+(2))
    return 0;
}
```

以上定义中，“替换列表”可缺省。这里要注意的是，类似函数的宏定义中，标识符与 ( 之间不应该存在任何空白符，否则预编译器可能会将 () 作为类似对象宏定义的替换列表中的一部分。

在 C 语言预处理过程中，替换列表会将当前宏标识符给完全替换掉。我们称两个替换列表是完全等同的，当且仅当该两个替换列表中的预处理符号（preprocessing token）的数量、次序、拼写以及空白分隔符的数量相同，对于所有空白分隔符都认为是等同的（比如一个 tab 制表符与一个空格符是完全相同的，因此 N 个空格符与一个空格符是等同的，当然这里 N 必须大于零）。

对类似函数的宏（以下简称为宏函数）的“调用”与一般 C 函数调用还有一点不同，即宏函数的实参可以不传，此时在宏替换时会使用占位标记（placemarker）预处理符号来代替。占位标记预处理符号在 C 语言语法上不会体现出来，它作为 C 语言预处理器的一种标准实现方式进行定义。

宏定义的作用范围是从它定义完的那个位置起一直到当前源文件结束，它不受语句块作用域、函数作用域等影响，预处理部分与 C 源代码正文部分采用的是完全不同的文法体系，而且预处理器（preprocessor）是独立于编译器而存在的。因此从严格意义上来说，我们在使用类似函数的宏的时候也不能将它称之为“调用”，一般称为“使用”。

# 预定义宏

C 语言标准指出了 C 语言实现（即 C 语言编译工具）要求必须实现的预定义宏以及可选实现的预定义宏。所谓预定义宏即不是由 C 语言程序员自己定义，而是由编译工具预先已经定义好的宏。

C 语言中的预定义宏分为三类：

1. C 语言标准强制要求预定义的宏；
2. 环境宏，它可选实现的预定义宏；
3. 条件特征宏，这也是实现可选实现的。

## 预定义宏

- `__DATE__`：此预定义宏用于表示当前日期的一个字符串字面量，其形式为"Mmm ddyyyy"。这里，Mmm 是月份的缩写，比如 1 月是 Jan, 2 月是 Feb。如果日小于 10，那么前面的一个 d 用一个空格字符表示。所以，如果是 2015 年 2 月 6 日，`__DATE__` 就表示为"Feb 2 2015"，这里 Feb 与 2 之间有两个空格。
- `__FILE__`：表示当前源文件名，用字符串字面量表示。
- `__LINE__`：表示当前源文件的当前行号，用一个整数常量表示。
- `__STDC__`：它表示一个常量值，如果该宏的值为 1，那么说明当前 C 语言实现顺应 C 语言标准。
- `__STDC_HOSTED__`：如果当前 C 语言实现是一个主机端实现，那么该预定义宏的值为 1；如果是独立式实现，那么该预定义宏的值为 0。所谓主机端实现是指当前 C 源代码最终编译为当前目标平台兼容的二进制代码文件，随后可以连接成能在当前目标平台上可直接执行的可执行文件。而独立式实现类则比较灵活，比如可以将当前 C 源代码编译为一种中间代码，然后可以以虚拟机的方式对该中间代码做解释执行。
- `__STDC_VERSION__`：该预定义宏表示一个整数常量（long 类型），用于指明当前正使用的 C 语言标准版本。比如，如果当前用的是 2011 年 12 月发布的 C 语言标准，那么整数常量为 201112L。
- `__TIME__`：表示当前时间的一个字符串字面量，其形式为"hh:mm:ss"。比如，22 时 55 分 30 秒则表示为"22:55:30"。

除了上述这些预定义宏之外，从 C99 标准起规定，C 语言实现还需要实现一个预定义标识符 `__func__`，该预定义标识符表示当前函数名，它被定义为：`static const char__func__[]="function-name"`;

此外，C 语言标准还强制规定了不能预定义 `__cplusplus` 该预定义宏，如果此宏被预定义，那么说明当前编译环境为 C++ 语言，而不是 C 语言。

主流编译器及平台预定义的宏:

- `_MSC_VER`：如果 C 语言实现预定义了这个宏，说明当前的编译器为 MSVC。
- `__GNUC__`：如果 C 语言实现预定义了这个宏，说明当前的编译器为 GCC 或兼容 GCC 的编译器。那么，如果我们在使用 Clang 编译器时，此宏也是被定义的。
- `__clang__`：如果 C 语言实现预定义了这个宏，说明当前的编译器为 Clang 编译器。
- `__i386__`：如果 C 语言实现预定义了这个宏，说明编译生成的目标为 32 位的 x86 处理器。
- `__x86_64__`：如果 C 语言实现预定义了这个宏，说明编译生成的目标为 x86_64 处理器，并运行在 64 位系统模式下的指令集。
- `__arm__`：如果 C 语言实现预定义了这个宏，说明编译生成的目标为 32 位 ARM 处理器。
- `__arm64__`：如果 C 语言实现预定义了这个宏，说明编译生成的目标为 64 位的 ARM 处理器。
- `__APPLE__`：如果 C 语言实现预定义了这个宏，说明编译生成的目标为 Apple 系统（包括 macOS、iOS、tvOS、watchOS 等）上的。
- `__unix__`：如果 C 语言实现预定义了这个宏，说明编译生成的目标是 Unix 或与其兼容的系统上的。
- `__linux__`：如果 C 语言实现预定义了这个宏，说明编译生成的目标是 Linux 或与其兼容的系统上的。
- `_WIN32`：如果 C 语言实现预定义了这个宏，说明编译生成的目标是 32 位 Windows 系统。
- `_WIN64`：如果 C 语言实现预定义了这个宏，说明编译生成的目标是 64 位 Windows 系统。
- `__LP64__`：如果 C 语言实现预定义了这个宏并且其整数常量为 1，那么说明当前程序运行环境为 64 位系统环境，此时 `long int` 类型的长度为 64 位，`int` 类型的长度仍然为 32 位。

## 环境宏

环境宏主要用于指明当前源文件输入字符编码的支持情况。这些宏都是可选实现，而不是必须实现的。

- `__STDC_ISO_10646__`：该预定义宏被定义为一个整数常量，形式与 `__STDC_VERSION__` 类似。如果遵循的 ISO10464 是 1997 年 12 月发布的，那么此宏的值为 199712L。如果 C 语言实现定义了这个宏，那么在 `wchar_t` 类型对象中存放的值，在 Unicode 要求字符集中的每一个 Unicode 与该字符所对应的短标识符具有相同的值。Unicode 要求字符集由 ISO/IEC 10646 定义的所有字符组成，此外还包括一些修改与技术勘误表。如果 C 语言实现使用了其他编码方式，那么就不能定义此宏。
- `__STDC_MB_MIGHT_NEQ_WC__`：如果该预定义宏的值为 1，那么指明当在一个整数字符常量中用作为单个字符时，`wchar_t` 类型的字符编码中，一些基本字符集的编码值不需要与其值相等。
- `__STDC_UTF_16__`：如果该预定义宏的整数常量值为 1，那么指明 `char16_t` 类型的值表示的是 UTF-16 编码的。如果 C 语言实现对 `char16_t` 类型的值采用的是其他编码类型，那么就不该定义此宏。
- `__STDC_UTF_32__`：如果该预定义宏的整数常量值为 1，那么指明 `char32_t` 类型的值是 UTF-32 编码的。如果 C 语言实现对 `char32_t` 类型的值采用的是其他编码方式，那么就不该定义此宏。

# 头文件

C 语言是一个可共享的编程语言，我们可以将自己的源代码编译成库，然后给其他开发人员使用。这样，一来可以对自己的源代码进行保护，因为库中的代码已经全都转为了平台相关的机器指令码，二来也不影响其他开发者对库中的函数接口进行调用。那么我们如何将自己源码中的对外函数接口以及数据类型等共享给其他开发者呢？答案就是通过头文件（header）！

C 语言中的头文件一般以 .h 作为后缀名，而且 C 语言编译器一般不会对 .h 文件进行编译，而 .h 头文件中的代码如果存在语法错误，则往往是在包含进源文件参与编译后由编译器发现的。在 C 语言预处理中使用 `#include` 预处理指示符将指定的文件包含到当前源文件中。

`#include` 有两种形式，一种是：

```c
#include <头文件名> 换行符
```

还有一种是：

```c
#include "头文件名" 换行符
```

第一种使用 <> 的形式会使得预处理器将 <> 中所指定文件的整个内容将 #include <头文件名> 这整个预处理指示符全都替换掉。其中，对 <> 中指定的文件路径的搜索是实现自定义的。对于主流桌面系统而言，<> 中指定的文件路径一般就是操作系统默认存放库头文件的系统路径或是由用户指定的系统环境路径。

而第二种 "" 的方式是由实现先通过另一种自定义的搜索方式对指定文件进行搜索，如果搜索到则进行内容替换；倘若搜索不到，则换用 <> 形式的搜索方式进行搜索，如果再搜索不到，则会出现编译出错。这里所谓的 "另一种实现自定义搜索方式"，对于主流桌面系统而言通常就是当前 C 语言项目工程下的路径。
