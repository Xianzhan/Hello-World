[硬件](#硬件)
 - [中央处理器](#中央处理器)
 - [存储器](#存储器)
 - [输入输出设备](#输入输出设备)
 - [总线](#总线)

[体系架构](#体系架构)
 - [异常控制流](#异常控制流)

[程序设计语言](#程序设计语言)

[编译器](#编译器)

[数据结构和算法](#数据结构和算法)

[软件工程](#软件工程)

[资源](#资源)

# 硬件

![](../.resource/System-Computer-hardware_hierarchy.png)

逻辑门; <br>
布尔运算; <br>
multiplexor (多路复用器); <br>
触发器 (flip-flop); <br>
寄存器 (register); <br>
RAM 单元; 计数器; <br>
硬件描述语言 (HDL, Hardware Description Language); <br>
芯片的仿真及测试.<br>

计算机最关键的三个部分：CPU,内存,I/O控制芯片。

![](../.resource/System-Computer-hardware_composition.png)

## 中央处理器

硬件系统的核心是中央处理器（Central Processing Unit，简称 CPU）。它主要由控制器、运算器等组成，并采用大规模集成电路工艺制成的芯片，又称微处理器芯片。

### 运算器

运算器又称算术逻辑单元（Arithmetic Logic Unit 简称 ALU）。它是计算机对数据进行加工处理的部件，包括算术运算（加、减、乘、除等）和逻辑运算（与、或、非、异或、比较等）。

### 控制器

控制器负责从存储器中取出指令，并对指令进行译码；根据指令的要求，按时间的先后顺序，负责向其它各部件发出控制信号，保证各部件协调一致地工作，一步一步地完成各种操作。控制器主要由指令寄存器、译码器、程序计数器、操作控制器等组成。

## 存储器

存储器是计算机记忆或暂存数据的部件。计算机中的全部信息，包括原始的输入数据。经过初步加工的中间数据以及最后处理完成的有用信息都存放在存储器中。而且，指挥计算机运行的各种程序，即规定对输入数据如何进行加工处理的一系列指令也都存放在存储器中。存储器分为内存储器（内存）和外存储器（外存）两种。

### 主存储器

也称内存, 直接与 CPU 相连, 是计算机的工作存储器, 计算机当前正在运行的程序与数据必须存放在主存内. 存取速度快, 但存储量小.

### 辅助存储器

也称外存, 存储容量大, 几乎存放计算机的所有信息, 在计算机实际执行程序和加式处理数据时, 辅助存储器中的信息需要先传入内存后才能被 CPU 使用.

## 输入输出设备

简称 I/O 设备, 是计算机与外界联系的桥梁, 输入设备是指能向计算机系统输入信息的设备, 输出设备是指能从计算机系统输出信息的设备.

## 总线

是连接计算机 CPU、内存、辅存、各种输入输出部件的一组物理信号线及其相关的控制电路, 是计算机中用于在各部件间运载信息的公共机构.

### 缓存一致性

1. 通过在总线加 `LOCK#` 锁的方式.
2. 通过缓存一致性协议(Cache Coherence Protocol), 如 MESI

在早期的 CPU 当中，是通过在总线上加 `LOCK#` 锁的形式来解决缓存不一致的问题。因为 CPU 和其他部件进行通信都是通过总线来进行的，如果对总线加 `LOCK#` 锁的话，也就是说阻塞了其他 CPU 对其他部件访问（如内存），从而使得只能有一个 CPU 能使用这个变量的内存。在总线上发出了 `LCOK#` 锁的信号，那么只有等待这段代码完全执行完毕之后，其他 CPU 才能从其内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。

但是由于在锁住总线期间，其他 CPU 无法访问内存，会导致效率低下。因此出现了第二种解决方案，通过缓存一致性协议来解决缓存一致性问题。

# 体系架构

异常控制流 ECF;<br>
内存管理; <br>
数学计算程序库; <br>
基本 I/O 驱动程序; <br>
屏幕管理; <br>
文件 I/O; <br>
对高级语言的支持.<br>

## 异常控制流

**系统概念** ECF 是操作系统用来实现 I/O、进程和虚拟存储器的基本机制.<br>
**应用程序和操作系统交互** 应用程序通过一个叫做 *陷阱 (trap)* 或者 *系统调用 (system call)* 的 ECF 形式, 向操作系统请求服务. 比如, 向磁盘写数据、从网络读取数据、创建一个新进程, 以及终止当前进程, 都是通过应用程序调用系统调用来实现的.<br>
**编写有趣的新应用程序** 操作系统为应用程序提供了强大的 ECF 机制, 用来创建新进程、等待进程终止、通知其它进程系统中的异常事件, 以及检测和响应这些事件.<br>
**理解并发** ECF 是计算机系统中实现并发的基本机制. 中断应用程序、进程和线程 (它们的执行时间上是重叠的) 执行的异常处理程序和中断应用程序执行的信号处理程序都是运行中的并发的例子.<br>
**理解软件异常如何工作** 像 C++ 和 Java 这样的语言通过 try、catch 以及 throw 语句来提供软件异常机制. 软件异常允许程序进行 *非本地* 跳转 (违反通常的调用/返回栈规则的跳转) 来响应错误情况. 非本地跳转是一种应用层 ECF, 在 C 中是通过 `setjmp` 和 `longjmp` 函数提供的.

### 异常

异常是异常控制流的一种形式, 它一部分由硬件实现的, 一部分由操作系统实现的.

系统中可能的每种类型的异常都分配了一个唯一的非负整数的 *异常号 (exception number)*. 其中一些号码由处理器的设计者分配的, 其它号码是由操作系统内核 (操作系统常驻存储器的部分) 的设计者分配的. 前者的实例包括被零除、缺页、存储器访问违例、断点以及算术溢出. 后者的事例包括系统调用和来自外部 I/O 设备的信号.

在系统启动时 (当计算机重启或者加电时), 操作系统分配和初始化一张称为 *异常表* 的跳转表, 使得条目 *k* 包含异常 *k* 的处理程序的地址. 

在运行时 (当系统在执行某个程序时), 处理器检测到发生了一个事件, 并且确定了相应的异常号 *k*. 随后, 处理器触发异常, 方法是执行间接过程调用, 通过异常表的条目 *k* 转到相应的处理程序. 异常号是到异常表中的索引, 异常表的起始地址放在一个叫做 *异常表基址寄存器 (exception table base register)* 的特殊 CPU 寄存器里.

异常类似于过程调用, 但是有一些重要的不同之处.
- 过程调用时, 在跳转到处理程序之前, 处理器将返回地址压入栈中. 然而, 根据异常的类型, 返回地址要么是当前指令 (当前时间发生时正在执行的指令), 要么是下一条指令 (如果事件不发生, 将会在当前指令后执行的指令).
- 处理器也把一些额外的处理器状态压到栈里, 在处理程序返回时, 重新开始被中断的程序会需要这些状态. 比如, 一个 IA32 系统将包含当前条件码和其它内容的 EFLAGS 寄存器压入栈中.
- 如果控制从一个用户程序转移到内核, 那么所有这些项目都压到内核栈中, 而不是压到用户栈中.
- 异常处理程序运行在 *内核模式* 下, 这意味着它们对所有的系统资源都有完全的访问权限.

[【底层原理】基本内存管理（上）](https://mp.weixin.qq.com/s/MGEMmrCxTfi8K8spebsC_w)<br>
[【底层原理】网络数据传输时经历了哪些buffer](https://mp.weixin.qq.com/s/ZaQ6rpT_jOyaEtW7YPNXZw)<br>
[【系统编程】高性能网络I/O入门（一）](https://mp.weixin.qq.com/s/IUlwCPvf8okbHsbfd1q2rA)<br>
[【系统编程】五种IO模型分析](https://mp.weixin.qq.com/s/9YXsJo_u2zVNqvABoGqfqg)

# 程序设计语言

基于对象 (object-based) 的设计和编程模式; <br>
抽象数据类型; <br>
作用域; <br>
语法和语义; <br>
引用 (reference) 机制.<br>

# 编译器

词法分析; <br>
自顶向下的语法分析; <br>
符号表 (symbol table); <br>
基于堆栈 (stack-based) 的虚拟机; <br>
代码生成; <br>
数组和对象的实现.<br>

![](https://raw.githubusercontent.com/Xianzhan/resources/master/pictures/20180503102918.png)

**预处理阶段** 预处理器 (cpp) 根据以字符 `#` 开头的命令, 修改原始的 C 程序. 比如 hello.c 中第一行的 `#include <stdio.h>` 命令告诉预处理器读取系统头文件 stdio.h 的内容, 并把它直接插入到程序文本中. 结果就得到另一个 C 程序, 通常是以 .i 作为文件扩展名.<br>
**编译阶段** 编译器 (cc1) 将文本文件 hello.i 翻译成文本文件 hello.s, 它包含一个*汇编语言程序*. 汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令. 汇编语言是非常有用的, 因为它为不同高级语言的不同编译器提供了通用的输出语言. 例如, C 编译器和 Fortran 编译器产生的输出文件用的都是一样的汇编语言.<br>
**汇编阶段** 接下来, 汇编器 (as) 将 hello.s 翻译成机器语言指令, 把这些指令打包成一种叫做*可重定位的目标程序 (relocatable object program)* 的格式, 并将结果保存在目标文件 hello.o 中. hello.o 文件是一个二进制文件, 它的字节编码是机器语言指令而不是字符. 如果我们在文件编辑器中打开 hello.o 文件, 看到的将是一堆乱码.<br>
**链接阶段** 请注意, hello 程序调用了 `printf()` 函数, 它是每个 C 编译器都会提供的标准 C 库中的一个函数. `printf()` 存在于一个名为 printf.o 的单独的预编译好的目标文件中, 而这个文件必须以某种方式合并到我们的 hello.o 程序中. 连接器 (ld) 就负责处理这种合并. 结果就得到 hello 文件, 它是一个*可执行目标文件 (或简称为可执行文件)*, 可以被加载到内存中, 由系统执行.

# 数据结构和算法

堆栈; <br>
哈希表; <br>
链表; <br>
递归; <br>
算术算法; <br>
几何算法; <br>
运行效率.<br>

# 软件工程

模块化设计; <br>
接口/实现范式; <br>
API 设计和文档; <br>
主动式测试 (即极限编程理论中的单元测试等); <br>
广义的程序设计概念; <br>
质量保证体系.<br>

# 资源

[程序员的自我修养：温故而知新](https://mp.weixin.qq.com/s/8rQKJxFaFDznrTRHmVNNQA)<br>
[Linux X86 程序启动 – main函数是如何被执行的？](https://luomuxiaoxiao.com/?p=516)<br>
