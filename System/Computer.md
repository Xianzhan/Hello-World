[硬件](#硬件)

[体系架构](#体系架构)
 - [异常控制流](#异常控制流)

[程序设计语言](#程序设计语言)

[编译器](#编译器)

[数据结构和算法](#数据结构和算法)

[软件工程](#软件工程)

[resources](#resources)

![](https://raw.githubusercontent.com/Xianzhan/resources/master/pictures/20180425152407.png)

# 硬件

逻辑门; <br>
布尔运算; <br>
multiplexor (多路复用器); <br>
触发器 (flip-flop); <br>
寄存器 (register); <br>
RAM 单元; 计数器; <br>
硬件描述语言 (HDL, Hardware Description Language); <br>
芯片的仿真及测试.<br>

计算机最关键的三个部分：CPU,内存,I/O控制芯片。

![](https://raw.githubusercontent.com/Xianzhan/resources/master/pictures/20180412105858.png)

# 体系架构

异常控制流 ECF;<br>
内存管理; <br>
数学计算程序库; <br>
基本 I/O 驱动程序; <br>
屏幕管理; <br>
文件 I/O; <br>
对高级语言的支持.<br>

## 异常控制流

**系统概念** ECF 是操作系统用来实现 I/O、进程和虚拟存储器的基本机制.<br>
**应用程序和操作系统交互** 应用程序通过一个叫做 *陷阱 (trap)* 或者 *系统调用 (system call)* 的 ECF 形式, 向操作系统请求服务. 比如, 向磁盘写数据、从网络读取数据、创建一个新进程, 以及终止当前进程, 都是通过应用程序调用系统调用来实现的.<br>
**编写有趣的新应用程序** 操作系统为应用程序提供了强大的 ECF 机制, 用来创建新进程、等待进程终止、通知其它进程系统中的异常事件, 以及检测和响应这些事件.<br>
**理解并发** ECF 是计算机系统中实现并发的基本机制. 中断应用程序、进程和线程 (它们的执行时间上是重叠的) 执行的异常处理程序和中断应用程序执行的信号处理程序都是运行中的并发的例子.<br>
**理解软件异常如何工作** 像 C++ 和 Java 这样的语言通过 try、catch 以及 throw 语句来提供软件异常机制. 软件异常允许程序进行 *非本地* 跳转 (违反通常的调用/返回栈规则的跳转) 来响应错误情况. 非本地跳转是一种应用层 ECF, 在 C 中是通过 `setjmp` 和 `longjmp` 函数提供的.

### 异常

异常是异常控制流的一种形式, 它一部分由硬件实现的, 一部分由操作系统实现的.

系统中可能的每种类型的异常都分配了一个唯一的非负整数的 *异常号 (exception number)*. 其中一些号码由处理器的设计者分配的, 其它号码是由操作系统内核 (操作系统常驻存储器的部分) 的设计者分配的. 前者的实例包括被零除、缺页、存储器访问违例、断点以及算术溢出. 后者的事例包括系统调用和来自外部 I/O 设备的信号.

在系统启动时 (当计算机重启或者加电时), 操作系统分配和初始化一张称为 *异常表* 的跳转表, 使得条目 *k* 包含异常 *k* 的处理程序的地址. 

在运行时 (当系统在执行某个程序时), 处理器检测到发生了一个事件, 并且确定了相应的异常号 *k*. 随后, 处理器触发异常, 方法是执行间接过程调用, 通过异常表的条目 *k* 转到相应的处理程序. 异常号是到异常表中的索引, 异常表的起始地址放在一个叫做 *异常表基址寄存器 (exception table base register)* 的特殊 CPU 寄存器里.

异常类似于过程调用, 但是有一些重要的不同之处.
- 过程调用时, 在跳转到处理程序之前, 处理器将返回地址压入栈中. 然而, 根据异常的类型, 返回地址要么是当前指令 (当前时间发生时正在执行的指令), 要么是下一条指令 (如果事件不发生, 将会在当前指令后执行的指令).
- 处理器也把一些额外的处理器状态压到栈里, 在处理程序返回时, 重新开始被中断的程序会需要这些状态. 比如, 一个 IA32 系统将包含当前条件码和其它内容的 EFLAGS 寄存器压入栈中.
- 如果控制从一个用户程序转移到内核, 那么所有这些项目都压到内核栈中, 而不是压到用户栈中.
- 异常处理程序运行在 *内核模式* 下, 这意味着它们对所有的系统资源都有完全的访问权限.

[【底层原理】基本内存管理（上）](https://mp.weixin.qq.com/s/MGEMmrCxTfi8K8spebsC_w)<br>
[【底层原理】网络数据传输时经历了哪些buffer](https://mp.weixin.qq.com/s/ZaQ6rpT_jOyaEtW7YPNXZw)<br>
[【系统编程】高性能网络I/O入门（一）](https://mp.weixin.qq.com/s/IUlwCPvf8okbHsbfd1q2rA)<br>
[【系统编程】五种IO模型分析](https://mp.weixin.qq.com/s/9YXsJo_u2zVNqvABoGqfqg)

# 程序设计语言

基于对象 (object-based) 的设计和编程模式; <br>
抽象数据类型; <br>
作用域; <br>
语法和语义; <br>
引用 (reference) 机制.<br>

# 编译器

词法分析; <br>
自顶向下的语法分析; <br>
符号表 (symbol table); <br>
基于堆栈 (stack-based) 的虚拟机; <br>
代码生成; <br>
数组和对象的实现.<br>

![](https://raw.githubusercontent.com/Xianzhan/resources/master/pictures/20180503102918.png)

**预处理阶段** 预处理器 (cpp) 根据以字符 `#` 开头的命令, 修改原始的 C 程序. 比如 hello.c 中第一行的 `#include <stdio.h>` 命令告诉预处理器读取系统头文件 stdio.h 的内容, 并把它直接插入到程序文本中. 结果就得到另一个 C 程序, 通常是以 .i 作为文件扩展名.<br>
**编译阶段** 编译器 (cc1) 将文本文件 hello.i 翻译成文本文件 hello.s, 它包含一个*汇编语言程序*. 汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令. 汇编语言是非常有用的, 因为它为不同高级语言的不同编译器提供了通用的输出语言. 例如, C 编译器和 Fortran 编译器产生的输出文件用的都是一样的汇编语言.<br>
**汇编阶段** 接下来, 汇编器 (as) 将 hello.s 翻译成机器语言指令, 把这些指令打包成一种叫做*可重定位的目标程序 (relocatable object program)* 的格式, 并将结果保存在目标文件 hello.o 中. hello.o 文件是一个二进制文件, 它的字节编码是机器语言指令而不是字符. 如果我们在文件编辑器中打开 hello.o 文件, 看到的将是一堆乱码.<br>
**链接阶段** 请注意, hello 程序调用了 `printf()` 函数, 它是每个 C 编译器都会提供的标准 C 库中的一个函数. `printf()` 存在于一个名为 printf.o 的单独的预编译好的目标文件中, 而这个文件必须以某种方式合并到我们的 hello.o 程序中. 连接器 (ld) 就负责处理这种合并. 结果就得到 hello 文件, 它是一个*可执行目标文件 (或简称为可执行文件)*, 可以被加载到内存中, 由系统执行.

# 数据结构和算法

堆栈; <br>
哈希表; <br>
链表; <br>
递归; <br>
算术算法; <br>
几何算法; <br>
运行效率.<br>

# 软件工程

模块化设计; <br>
接口/实现范式; <br>
API 设计和文档; <br>
主动式测试 (即极限编程理论中的单元测试等); <br>
广义的程序设计概念; <br>
质量保证体系.<br>

# resources

[程序员的自我修养：温故而知新](https://mp.weixin.qq.com/s/8rQKJxFaFDznrTRHmVNNQA)
