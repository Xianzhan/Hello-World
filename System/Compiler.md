<!-- TOC -->

- [编译原理](#编译原理)
    - [计算机程序设计及编译](#计算机程序设计及编译)
    - [编译器在语言处理系统的位置](#编译器在语言处理系统的位置)
    - [编译系统的结构](#编译系统的结构)
- [编译器](#编译器)

<!-- /TOC -->

# 编译原理

## 计算机程序设计及编译

**机器语言**

```
C706 0000 0002
```

可以被计算机直接理解。

缺点：1. 与人类表达习惯相去甚远；2. 难记忆；3. 难编写，难阅读。

**汇编语言**

```
MOV X, 2
```

引入助记符。将汇编语言翻译成机器语言的过程叫做汇编。

缺点：1. 依赖特定机器，非计算机专业人员使用受限制；2. 编写效率依然很低

**高级语言**

```
x = 2
```

类似于数学定义或自然语言的简洁形式。*将高级语言编译成汇编语言或者机器语言的过程叫做编译。*

优点：1. 接近人类表达习惯；2. 不依赖于特定机器；3. 编写效率高

## 编译器在语言处理系统的位置

```
          源程序
            ↓
  [预处理器(Preprocessor)]
            ↓
     经过预处理的源程序
            ↓
         [编译器]
            ↓
       汇编语言程序
            ↓
     [汇编器(Assembler)]
            ↓
     可重定位的机器代码
            ↓
[链接器(Linker)/加载器(Loader)]
            ↓
        目标机器代码
```

**预处理器**

1. 把存储在不同文件中的源程序*聚合*在一起
2. 把被称为*宏*的缩写语句转换为原始语句

**汇编器**

可重定位(Relocatable): 在内存中存放的起始位置 L 不是固定的。

起始位置 + 相对位置 = 绝对位置

**链接器**

1. 将多个可重定位的机器代码文件（包括库文件）连接到一起
2. 解决外部内存地址问题

**加载器**

修改可重定位地址：将修改后的指令和数据放到内存中适当的位置。

## 编译系统的结构

**语义分析 Semantic analysis**

![Semantic analysis](../.resource/System-Compiler-semantic_analysis.png)

划分句子成分

**语法分析 Syntax analysis**

![Syntax analysis](../.resource/System-Compiler-syntax_analysis.png)

识别句子的各类短语

**词法分析 Lexical analysis**

![Lexical analysis](../.resource/System-Compiler-lexical_analysis.png)

确定单词的词性或者说词类

![Translation](../.resource/System-Compiler-translation.png)

**结构**

![Structure](../.resource/System-Compiler-structure.png)

# 编译器

词法分析; <br>
自顶向下的语法分析; <br>
符号表 (symbol table); <br>
基于堆栈 (stack-based) 的虚拟机; <br>
代码生成; <br>
数组和对象的实现.<br>

![](https://raw.githubusercontent.com/Xianzhan/resources/master/pictures/20180503102918.png)

**预处理阶段** 预处理器 (cpp) 根据以字符 `#` 开头的命令, 修改原始的 C 程序. 比如 hello.c 中第一行的 `#include <stdio.h>` 命令告诉预处理器读取系统头文件 stdio.h 的内容, 并把它直接插入到程序文本中. 结果就得到另一个 C 程序, 通常是以 .i 作为文件扩展名.<br>
**编译阶段** 编译器 (cc1) 将文本文件 hello.i 翻译成文本文件 hello.s, 它包含一个*汇编语言程序*. 汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令. 汇编语言是非常有用的, 因为它为不同高级语言的不同编译器提供了通用的输出语言. 例如, C 编译器和 Fortran 编译器产生的输出文件用的都是一样的汇编语言.<br>
**汇编阶段** 接下来, 汇编器 (as) 将 hello.s 翻译成机器语言指令, 把这些指令打包成一种叫做*可重定位的目标程序 (relocatable object program)* 的格式, 并将结果保存在目标文件 hello.o 中. hello.o 文件是一个二进制文件, 它的字节编码是机器语言指令而不是字符. 如果我们在文件编辑器中打开 hello.o 文件, 看到的将是一堆乱码.<br>
**链接阶段** 请注意, hello 程序调用了 `printf()` 函数, 它是每个 C 编译器都会提供的标准 C 库中的一个函数. `printf()` 存在于一个名为 printf.o 的单独的预编译好的目标文件中, 而这个文件必须以某种方式合并到我们的 hello.o 程序中. 连接器 (ld) 就负责处理这种合并. 结果就得到 hello 文件, 它是一个*可执行目标文件 (或简称为可执行文件)*, 可以被加载到内存中, 由系统执行.
