<!-- TOC -->

- [线程隔离](#线程隔离)
    - [程序计数器](#程序计数器)
    - [虚拟机栈](#虚拟机栈)
    - [本地方法栈(native stack)](#本地方法栈native-stack)
- [线程共享](#线程共享)
    - [堆](#堆)
    - [元空间](#元空间)
        - [SymbolTable](#symboltable)
        - [StringTable](#stringtable)
- [直接内存](#直接内存)
    - [分配和回收](#分配和回收)
- [资源](#资源)

<!-- /TOC -->

```shell
*.class
    ↓
+-----------------------------------------------------------+
| +------------------------+ +----------------------------+ |
| |                        | |                            | |
| |     Thread private     | |      Thread sharing        | | # 线程私有       线程共享
| |                        | |                            | |
| | +--------------------+ | | +------------+ +---------+ | |
| | |     PC register    | | | |            | |         | | | # PC 寄存器
| | +--------------------+ | | |            | |         | | |
| | +--------------------+ | | |            | |         | | |
| | |  Java method stack | | | |  Metadata  | |   Heap  | | | # Java 方法栈    方法区 堆
| | +--------------------+ | | |            | |         | | |
| | +--------------------+ | | |            | |         | | |
| | | Local method stack | | | |            | |         | | | # 本地方法栈
| | +--------------------+ | | +------------+ +---------+ | |
| +------------------------+ +----------------------------+ |
|                                                           |
|                   Java virtual machine                    | # Java 虚拟机
|                                                           |
+-----------------------------------------------------------+
```

# 线程隔离

```shell
+----------------------------+
|                            |
|         Main thread        | # main 线程
|                            |
|+--------------------------+|
||                          ||
||       Program counter    || # 程序计数器
||                          ||
|+--------------------------+|
|+--------------------------+|
||                          ||
||        Stack frame       || # 栈帧
||                          ||
||+------------------------+||
|||                        |||
|||       method frame     ||| # 某个方法栈帧
|||                        |||
|||+----------------------+|||
|||| Local variable table |||| # 某个方法的局部变量表
|||+----------------------+|||
|||+----------------------+|||
||||     Operand stack    |||| # 某个方法的操作数栈
|||+----------------------+|||
|||+----------------------+|||
||||      Dynamic link    |||| # 某个方法的动态链接
|||+----------------------+|||
|||+----------------------+|||
||||      Method exit     |||| # 某个方法的方法出口
|||+----------------------+|||
||+------------------------+||
||+------------------------+||
|||                        |||
|||       main frame       ||| # main 方法栈帧
|||                        |||
||+------------------------+||
|+--------------------------+|
|+--------------------------+|
||                          ||
||   Native method frame    || # 本地方法栈
||                          ||
|+--------------------------+|
+----------------------------+
```

## 程序计数器

Program Counter Register 程序计数器(寄存器的抽象)

作用: 记住下一条 jvm 指令的执行地址<br>

特点:

- 线程私有
- 不会存在内存溢出

## 虚拟机栈

Java Virtual Machine Stacks Java 虚拟机栈

- 每个线程运行时所需要的内存, 称为虚拟机栈
- 每个栈由多个栈帧(Frame)组成, 对应着每次方法调用时所占用的内存
- 每个线程只能有一个活动栈帧, 对应着当前正在执行的那个方法, 即栈顶的方法

**栈溢出**

`java.lang.StackOverflowError`

1. 栈帧过多, 如没有正确的递归出口
2. 栈帧过大, 过多局部变量

## 本地方法栈(native stack)

与虚拟机栈类似，虚拟机栈为 Java 程序服务，本地方法栈支持虚拟机的运行服务，具体实现由虚拟机厂商决定，也会抛出 StackOverFlowError、OutOfMemory 异常。

# 线程共享

Java 1.7 之前分为 `堆`, `永久代`(`方法区`, `常量区`)<br>
Java 1.7 分为 `堆`, `永久代`(`方法区`)<br>
Java 8 分为 `堆`, `元空间`<br>

## 堆

Heap

```shell
+--------------------------------------------------------------------+
|                               Heap                                 |
|                 +--------- Survivor ---------+                     |
|+------------+   +------------+    +----------+   +----------------+|
|| Eden(8/10) | → | From(1/10) | ←→ | To(1/10) | → | Old Generation ||
|+------------+   +------------+    +----------+   +----------------+|
|+--------------- Young generation ------------+                     |
+--------------------------------------------------------------------+
```

是虚拟机管理内存中最大的一部分，被所有线程共享，用于存放对象实例(对象、数组)，物理上不连续的内存空间，由于 GC 收集器，分代收集，所以划分为：新生代 Eden、From SurVivor 空间、To SurVivor 空间，allow buffer(分配空间)，可能会划分出多个线程私有的缓冲区，老年代。

**年轻代(Young)**

年轻代一般占堆的 1/3, 大多数对象在新生代中被创建，其中很多对象的生命周期很短.

年轻代内又分三个区：一个 Eden(8/10) 区，两个 Survivor(from 1/10, to 1/10) 区，大部分对象在 Eden 区中生成。每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性地拷贝到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor.

**老年代(Old)**

老年代（Old Generation）一般占堆的 2/3, 在新生代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代，或者大对象直接进入老年代。该区域中对象存活率高。

## 元空间

Java 8 中用元空间替代了永久代, 元空间并**不在虚拟机中，而是使用本地内存**

**方法区(method area)**

与堆一样属于线程共享的内存区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码（动态加载 OSGI）等数据。理论上属于 java 虚拟机的一部分，为了区分开来叫做 Non-Heap 非堆。

这个区域可以选择不进行垃圾回收，该区域回收目的主要是常量池的回收，及类型的卸载 class, 内存区不足时会抛出 OutOfMemory 异常

**运行时常量池**

方法区的一部分，Class 的版本、字段、接口、方法等，及编译期生成的各种字面量、符号引用，编译类加载后存放在该区域。会抛出 OutOfMemory 异常。

### SymbolTable

> Symbolic references in Runtime Constant Pool

### StringTable

> 字符串常量池

# 直接内存

Direct Memory

- 常见于 NIO 操作时, 用于数据缓冲区
- 分配回收成本较高, 但读写性能高
- 不受 JVM 内存回收管理, 即无需再复制到堆内存中

## 分配和回收

- 使用了 Unsafe 对象完成直接内存的分配和回收, 并且回收需要主动调用 freeMemory 方法
- ByteBuffer 的实现, 使用了 Cleaner(虚引用)来监测 ByteBuffer 对象, 一旦 ByteBuffer 对象被垃圾回收, 那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存

# 资源

[Java锁的升级策略 偏向锁 轻量级锁 重量级锁](https://www.cnblogs.com/pomer-huang/p/10965228.html)<br>
[volatile关键字？MESI协议？指令重排？内存屏障？这都是啥玩意](https://www.cnblogs.com/hello-shf/p/12091591.html)<br>
