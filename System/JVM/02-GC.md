<!-- TOC -->

- [GC](#gc)
- [垃圾回收算法](#垃圾回收算法)
    - [引用计数法](#引用计数法)
    - [根搜索算法](#根搜索算法)
- [垃圾回收器](#垃圾回收器)
    - [Serial](#serial)
    - [ParNew](#parnew)
    - [Parallel Scavenge](#parallel-scavenge)
    - [Parallel Old](#parallel-old)
    - [CMS](#cms)
    - [G1](#g1)
    - [ZGC](#zgc)

<!-- /TOC -->

# GC

JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。

其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。

而 Java 堆区和方法区则不一样，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。

垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！

**方法区回收**

方法区主要回收的内容有：废弃常量和无用的类。

对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面 3 个条件：

1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例；
2. 加载该类的 `ClassLoader` 已经被回收；
3. 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

# 垃圾回收算法

## 引用计数法

引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。

当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为 1。

当任何其它变量被赋值为这个对象的引用时，计数加 1（a = b, 则 b 引用的对象实例的计数器 +1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减 1。

任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。

**优缺点**

优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。

缺点：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为 0。

## 根搜索算法

(可达性分析算法)

可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点 GC ROOT 开始，寻找对应的引用节点

找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。

在 Java 语言中，可作为 GC Roots 的对象包括下面几种：

- 虚拟机栈中引用的对象（栈帧中的本地变量表）；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中 JNI（Native 方法）引用的对象。

**标记-清除算法**

标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记

标记完毕后，再扫描整个空间中未被标记的对象，进行回收

标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效

但由于标记-清除算法直接回收不存活的对象，因此会造成*内存碎片*

**复制算法**

复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。

它开始时把堆分成 一个对象面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于 copying 算法的垃圾收集就从根集合（GC Roots）中扫描活动对象，并将每个活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)

这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。

**标记-整理算法**

标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。

标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。

**分代收集算法**

分代收集算法是目前大部分 JVM 的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。

一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。

老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

- 年轻代（Young Generation）的回收算法

a) 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。

b) 新生代内存按照 8:1:1 的比例分为一个 eden 区和两个 survivor(survivor0,survivor1) 区。

大部分对象在 Eden 区中生成，回收时先将 eden 区存活对象复制到一个 survivor0 区，然后清空 eden 区。

当这个 survivor0 区也存放满了时，则将 eden 区和 survivor0 区存活对象复制到另一个 survivor1 区，然后清空 eden 和这个 survivor0 区，此时 survivor0 区是空的

然后将 survivor0 区和 survivor1 区交换，即保持 survivor1 区为空， 如此往复。

c) 当 survivor1 区不足以存放 eden 和 survivor0 的存活对象时，就将存活对象直接存放到老年代。

若是老年代也满了就会触发一次 Full GC，也就是新生代、老年代都进行回收。

d) 新生代发生的 GC 也叫做 Minor GC，MinorGC 发生频率比较高(不一定等 Eden 区满了才触发)。

- 年老代（Old Generation）的回收算法

a) 在年轻代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。

因此，可以认为年老代中存放的都是一些生命周期较长的对象。

b) 内存比新生代也大很多(大概比例是 1:2)，当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率标记高。

- 持久代（Permanent Generation）的回收算法

用于存放静态文件，如 Java 类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class，例如 Hibernate 等，

在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。

持久代也称方法区

# 垃圾回收器

收集器|串行/并行/并发|新/老|算法|目标|适用场景
:---:|:---:|:---:|:---:|:---|:---
Serial|串行|新生代|复制算法|响应速度优先|单 CPU 环境下的 Client 模式
Serial Old|串行|老年代|标记-整理|响应速度优先|单 CPU 环境下的 Client 模式、CMS 的后备预案
ParNew|并行|新生代|复制算法|响应速度优先|多 CPU 环境时在 Server 模式下与 CMS 配合
Parallel Scavenge|并行|新生代|复制算法|吞吐量优先|在后台运算而不需要太多交互的任务
Parallel Old|并行|老年代|标记-整理|吞吐量优先|在后台运算而不需要太多交互的任务
CMS|并发|老年代|标记-清除|响应速度优先|集中在互联网站或 B/S 系统服务端上的 Java 应用
G1|并发|both|标记-整理+复制算法|响应速度优先|面向服务端应用，将来替换CMS

## Serial

工作模式

```bash
      User Thread 1 |            |         |            |
CPU 0 ------------> |            | ------> |            | --->
      User Thread 2 | GC Thread  |         | GC Thread  |
CPU 1 ------------> | ---------> | ------> | ---------> | --->
      User Thread 3 |            |         |            |
CPU 2 ------------> |            | ------> |            | --->
      User Thread 4 |            |         |            |
CPU 3 ------------> | New        | ------> | Old        | --->
                SafePoint              SafePoint
```

**新生代 Serial**

1. 单线程
2. 标记-复制算法
3. 暂停所有用户线程

**老年代 Serial Old**

1. 单线程
2. 标记-整理算法
3. 暂停所有用户线程
4. 主要用于 Client 模式下的虚拟机使用

## ParNew

工作模式

```bash
      User Thread 1 |              |         |            |
CPU 0 ------------> |              | ------> |            | --->
      User Thread 2 | GC Thread 1  |         | GC Thread  |
CPU 1 ------------> | -----------> | ------> | ---------> | --->
      User Thread 3 |              |         |            |
CPU 2 ------------> | GC Thread 2  | ------> |            | --->
      User Thread 4 | -----------> |         |            |
CPU 3 ------------> | New          | ------> | Old        | --->
                SafePoint              SafePoint
```

Parnew 是 Serial 收集器的**多线程**版本，也是**新生代**收集器。ParNew 收集器和 Serial 收集器除了多线程工作外几乎是相同的，包括所有控制参数、收集算法、stop the world，对象分配规则，回收策略等都是一样的。

虽然与 Serial 收集器相比仅仅多了多线程特性外，没有其它的创新之处，但是它却是许多 Server 模式下的虚拟机新生代收集器的首选，原因在于目前为止只有 Serial 和 ParNew 两个新生代收集器能够与性能优异的 CMS 配合使用。更加注重吞吐率。

## Parallel Scavenge

Parallel Scavenge 也是一款使用多线程**复制算法**的新生代收集器。该收集器与其它收集器不同的是，它关注的目标是达到一个可控制的吞吐量，而 CMS 等收集器的关注点则是尽可能地减少用户线程地停顿时间，提高用户体验。Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的 `-XX:MaxGCPauseMillis` 参数以及直接设置吞吐量大小的 `-XX:GCTimeRatio` 参数。也因此，Parallel Scavenge 被成为 “吞吐量优先” 收集器。

停顿时间越短就越适合与用户交互较多地程序，这样用户体验才更好。而高吞吐量则可以让出更多的 cpu 资源给用户线程，让程序更快的完成运算任务，更适合后台运算较多而不需要与用户交互的程序。

自适应调节策略是 Parallel Scavenge 收集器的特点，也是与 ParNew 收集器的区别。Parallel Scavenge 通过打开 `-XX:+UseAdaptiveSizePolicy` 的设置，就不需要手动地调节新生代（`-Xmn`）大小，Eden 和Survivor 区的比例（`-XX:SurvivorRatio`）、晋升老年代对象年龄（`-XX:PretenureSizeThreshold`）等细节参数，而是根据当前系统运行情况来确定这些参数，从而提高程序地吞吐量和缩短停顿时间，这一过程称之为 GC 自适应的调节策略（GC Ergonomics）。

另外值得注意的一点是，Parallel Scavenge 无法已 CMS 配合使用，如果新生代选择了 Parallel Scavenge 收集器，那么老年代的收集器只能选用 Serial Old 或者 Parallel Old 来配置使用。

## Parallel Old

工作模式

```bash
      User Thread 1 |              |         |              |
CPU 0 ------------> |              | ------> |              | --->
      User Thread 2 | GC Thread 1  |         | GC Thread 1  |
CPU 1 ------------> | -----------> | ------> | -----------> | --->
      User Thread 3 |              |         |              |
CPU 2 ------------> | GC Thread 2  | ------> | GC Thread 1  | --->
      User Thread 4 | -----------> |         | -----------> |
CPU 3 ------------> | New          | ------> | Old          | --->
                SafePoint                SafePoint
```

Parallel Old 是 Parallel Scavenge 的老年代版本，也是一个并行收集器，使用 “标记-整理” 算法。该收集器在 jdk1.6 后对外提供使用，Parallel Scavenge 和  Parallel Old 配合使用的话，更加适合应用于**高吞吐量**和 cpu 敏感资源的场合。

## CMS

工作模式

```bash
      User Thread 1 |         |              |         |              |
CPU 0 ------------> |         |              |         |              | 
      User Thread 2 |         | User Thread  | Step 3  | User Thread  | User Thread
CPU 1 ------------> | Step 1  | -----------> | ------> | -----------> | ----------->
      User Thread 3 | ------> |              |         |              |
CPU 2 ------------> |         |    Step 2    | Step 3  |    Step 4    |   重置线程
      User Thread 4 |         | -----------> | ------> | -----------> | ----------->
CPU 3 ------------> |         |              |         |              | 
                SafePoint SafePoint      SafePoint SafePoint      SafePoint
```

CMS（Concurrent Mark Sweep）是一个老年代**并发**收集器，使用了 “标记-清除” 算法来实现的。该收集器最求的更短的停顿时间，从而提升用户体验，因此也非常符合使用在网站、B/S 系统的服务端的应用。

CMS 收集器的工作流程大概可以分为以下 4 个步骤：

- Step 1 初始标记：这个阶段仅仅标记能够和 gc roots 直接关联的对象，速度很快，但是需要 “stop the world”。
- Step 2 并发标记：这个阶段开始进行 gc roots tracing 标记，与用户线程一起执行的，消耗时间很多。
- Step 3 重新标记：这个阶段是要是修正在并发标记期间由于用户线程也在运行而产生标记变动的那部分对象的标记，比较耗费的时间比初始标记阶段要长，但是远比并发标记阶段要短，这个过程也是需要 “stop the world” 的。
- Step 4 并发清除：对无用对象进行回收操作。这个过程与用户线程并行执行。

由于标记和清除阶段可以和用户线程一起工作，因此几乎可以把CMS收集器的工作是并发的：

CMS是一款优秀的收集器，它的主要优点是低停顿，并发收集，因此也被成为并发低停顿收集器（Concurrent Low Pause Collector）。

当然，CMS收集器也有一定的缺点，主要包括一下几点：

1. CMS 收集器使用 “标记-清除” 算法实现，因此不可避免地有内存碎片地问题。当内存碎片过多时，在分配大对象地过程中即使有足够的空间，但是找不到足够地连续的空间来放该对象，那么就有可能触发一次 full gc。
2. 无法处理浮动垃圾（Floating Garbage） 可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。这是因为在标记的过程中用户线程也在运行着，那么在这一过程中出现的垃圾无法立即回收，而是等下一次 gc 才能清理，我这部分的垃圾就叫做 “浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。
3. 对 cpu 资源非常敏感。其实，只要是面对并发的情况下都会有这个问题，在并发阶段虽然不会中断用户线程，但是因为占用了部分用户的资源而导致程序变慢，总吞吐量降低。CMS 搜集器默认的线程数 = （cpu核数 + 3） / 4，当 cpu 数量大于 4 时，垃圾回收线程数不少于 25%，随着线程数的增加而下降，当 cpu 数量小于 4 时对线程的执行效率有显著的影响。

[好文推荐：CMS学习笔记！！！](https://mp.weixin.qq.com/s/-yqJa4dOyzLaK_tJ1x9E7w)<br>

## G1

G1 (Garbage First) 是一个横跨新生代和老年代的垃圾回收器。直接将堆分成极其多个区域，每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。采用 标记-压缩算法，而且和 CMS 一样都能够在应用程序运行过程并发地进行垃圾回收。优先回收死亡对象较多的区域。

G1（Garbage-First）是一款面向服务端应用的垃圾收集器，JDK 7 Update4 后开始进入商用。HotSpot 开发团队赋予它的使命是未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。之前提供的收集器都是仅作用于新生代或者是老年代，但是 G1 收集器可以作用于新生代和老年代，因为使用 G1 收集器是 java heap 的内存结构有很大的不同，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但是他们已经没有了物理上的隔阂了，它们都是 region 的一部分的集合。

G1 收集器是当今收集器技术发展的最前沿成果之一，与其他收集器相比，G1 收集器具有以下特征：

- 并行与并发： G1 能充分利用多 CPU，多核环境下的硬件优势，使用多个 CPU 来缩短 Stop-The-World 停顿时间，部分其他收集器原本需要停顿 java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- 分代收集： 与其他收集器一样，分代概念在 G1 中仍然得以保留。虽然 G1 可以不需要其他收集器配合能够独立管理整个堆，但它能够采用不用的方式去处理新创的对象和已经存活了一段世纪那、熬过多次 GC 的旧对象以获得更好的收集效果。
- 空间整合： 与 CMS 的 “标记-清除” 算法不同，G1 整体来看采用了 “标记-整理” 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 “复制” 算法实现的。无论使用哪一种方法，都意味着 G1 运作期间不会产生内存空间碎片的问题，收集后能提供规整的可用空间。这种特性有利于程序长时间运行，分配大对象是不会因为无法得到连续内存空间而提前处罚一次 GC。
- 可预测的停顿： 这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了最求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒，这几乎是 java（RTSJ）的垃圾收集器的特征了。

G1 收集器之所以能够建立可预测的停顿时间模型，因为他能够有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要的经验值），在后台维护一个优先表，每次根据允许的收集时间，优先回收价值最大的 Region。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。

在 G1 收集器中，Region 之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用，虚拟机都是使用 Remembered Set 来避免全堆扫描的。G1 中每个 Region 都有一个与之对应的 Remembered Set，虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 中，如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 中的 Remembered Set 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描，也不会有遗漏。

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致分为以下几个步骤：

1. 初始标记（Initial Marking）： 这阶段仅仅只是标记 GC Roots 能直接关联到的对象并修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确的可用的 Region 中创建新对象，这阶段需要停顿线程，但是耗时很短。
2. 并发标记（Concurrent Marking）： 从 GC Roots 开始对堆的对象进行可达性分析，找出存活的对象，这阶段耗时长，但是可以与用户程序并发执行。
3. 最终标记（Final Marking）： 为了修正在并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录记录在线程 Remembered Set Logs 里面。
4. 筛选回收（Live Data Counting and Evacuation）： 首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，这一阶段是可以与用户程序一起并发执行的，但是因为只回收部分 Region，时间是用户可控的，而且停顿用户线程将大幅度提高收集效率。

[好文推荐：G1学习笔记！！！](https://mp.weixin.qq.com/s/CG-k-Vqw3LVUyUjnDpPmFw)<br>

## ZGC

[The Z Garbage Collector](http://openjdk.java.net/projects/zgc/)<br>