<!-- TOC -->

- [内存结构](#内存结构)
    - [锁](#锁)
    - [线程隔离](#线程隔离)
        - [虚拟机栈(stack)](#虚拟机栈stack)
        - [本地方法栈(native stack)](#本地方法栈native-stack)
        - [程序计数器(program counter register)](#程序计数器program-counter-register)
    - [线程共享](#线程共享)
        - [元空间](#元空间)
        - [堆(heap)](#堆heap)
- [class 文件格式](#class-文件格式)
    - [生命周期](#生命周期)
        - [加载 Loading](#加载-loading)
        - [链接 Linking](#链接-linking)
        - [初始化 Initalization](#初始化-initalization)
        - [使用 Using](#使用-using)
        - [卸载 Unloading](#卸载-unloading)
    - [字节码](#字节码)
- [GC](#gc)
    - [垃圾回收算法](#垃圾回收算法)
        - [引用计数法](#引用计数法)
        - [根搜索算法](#根搜索算法)
    - [垃圾回收器](#垃圾回收器)
        - [Serial](#serial)
        - [ParNew](#parnew)
        - [Parallel Scavenge](#parallel-scavenge)
        - [Parallel Old](#parallel-old)
        - [CMS](#cms)
        - [G1](#g1)

<!-- /TOC -->

Java 虚拟机（Java Virtual Machine）

# 内存结构

![https://static001.geekbang.org/resource/image/ab/77/ab5c3523af08e0bf2f689c1d6033ef77.png](../.resource/System-JVM-memory_model.png)

## 锁

[Java锁的升级策略 偏向锁 轻量级锁 重量级锁](https://www.cnblogs.com/pomer-huang/p/10965228.html)<br>

## 线程隔离

### 虚拟机栈(stack)

是线程私有的，声明周期与线程相同，虚拟机栈是 Java 方法执行的内存模型，每个方法被执行时都会创建一个栈帧，即方法运行期间的基础数据结构，栈帧用于存储：局部变量表、操作数栈、动态链接、方法出口等，每个方法执行中都对应虚拟机栈帧从入栈到处栈的过程。

是一种数据结构，是虚拟机中的局部变量表，对应物理层之上的程序数据模型。

局部变量表，是一种程序运行数据模型，存放了编译期可知的各种数据类型例如：

boolean、byte、char、short、int、float、long、double、对象引用类型(对象内存地址变量，指针或句柄)，程序运行时，根据局部变量表分配栈帧空间大小，在运行中，大小是不变的异常类型：StackOverFlowError 线程请求栈深度大于虚拟机允许深度 OutOfMemory 内存空间耗尽无法进行扩展。

### 本地方法栈(native stack)

与虚拟机栈类似，虚拟机栈为 Java 程序服务，本地方法栈支持虚拟机的运行服务，具体实现由虚拟机厂商决定，也会抛出 StackOverFlowError、OutOfMemory 异常。

### 程序计数器(program counter register)

行号指示器，字节码指令的分支、循环、跳转、异常处理、线程恢复(CPU 切换)，每条线程都需要一个独立的计数器，线程私有内存互不影响,该区域不会发生内存溢出异常。

## 线程共享

Java 1.7 之前分为 `堆`, `永久代`(`方法区`, `常量区`)<br>
Java 1.7 分为 `堆`, `永久代`(`方法区`)<br>
Java 8 分为 `堆`, `元空间`<br>

### 元空间

Java 8 中用元空间替代了永久代, 元空间并不在虚拟机中，而是使用本地内存

**方法区(method area)**

与堆一样属于线程共享的内存区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码（动态加载OSGI）等数据。理论上属于 java 虚拟机的一部分，为了区分开来叫做 Non-Heap 非堆。

这个区域可以选择不进行垃圾回收，该区域回收目的主要是常量池的回收，及类型的卸载class,内存区不足时会抛出 OutOfMemory 异常

**运行时常量池**

方法区的一部分，Class 的版本、字段、接口、方法等，及编译期生成的各种字面量、符号引用，编译类加载后存放在该区域。会抛出 OutOfMemory 异常。

### 堆(heap)

![https://time.geekbang.org/column/article/13137](../.resource/System-JVM-memory_heap.png)

是虚拟机管理内存中最大的一部分，被所有线程共享，用于存放对象实例(对象、数组)，物理上不连续的内存空间，由于 GC 收集器，分代收集，所以划分为：新生代 Eden、From SurVivor 空间、To SurVivor 空间，allow buffer(分配空间)，可能会划分出多个线程私有的缓冲区，老年代。

**年轻代(Young)**

年轻代一般占堆的 1/3, 大多数对象在新生代中被创建，其中很多对象的生命周期很短.

年轻代内又分三个区：一个 Eden(8/10) 区，两个 Survivor(from 1/10, to 1/10) 区，大部分对象在 Eden 区中生成。每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性地拷贝到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor.

**老年代(Old)**

老年代（Old Generation）一般占堆的 2/3, 在新生代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代，或者大对象直接进入老年代。该区域中对象存活率高。

# class 文件格式

1. 基本信息，涵盖了原 class 文件的相关信息。
2. 常量池，用来存放各种常量以及符号引用。
3. 字段区域，用来列举该类中的各个字段。
4. 方法区域，用来列举该类中的各个方法。

Java 虚拟机所使用的一种平台中立(不依赖于特定硬件及操作系统)的二进制格式表示。

[一张图看懂JVM之类装载系统](https://mp.weixin.qq.com/s/UU4qltVgRsj0SG7YmER-Qw)<br>

## 生命周期

```bash
# 类的生命周期

        加载 Loading
            ↓
        链接 Linking
            ↓
      初始化 Initalization
            ↓
        使用 Using
            ↓
        卸载 Unloading
```

**类加载器**

1. 启动类加载器（Bootstrap ClassLoader）：加载 lib/ 中类，不可直接使用
2. 扩展类加载器（Extension ClassLoader）：加载 lib/ext/ 的类库，可直接使用
3. 应用程序类加载器（Application ClassLoader）：负责加载用户类路径上所指定的类，可直接使用。

**双亲委派模型**

如果一个类加载器收到了类加载的请求，他不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成。只有父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去加载。

### 加载 Loading

类加载指的是类的生命周期中加载、链接、初始化三个阶段.

在加载阶段, 虚拟机需要完成以下 3 件事:

1. 通过一个类的全限定名来获取定义此类的二进制字节流.
2. 将这个字节流代表的静态存储结构转化为方法区的运行时数据结构.
3. 在内存中生成一个代表这个类的 `java.lang.Class` 对象, 作为这个类各种数据的访问入口.

**此外 JVM 判断两个 java.lang.Class 是否相同不仅要依据类的全路径描述符，还要保证是同一个 ClassLoader 加载。**

### 链接 Linking

连接阶段比较复杂，一般会跟加载阶段和初始化阶段交叉进行，这个阶段的主要任务就是做一些加载后的验证工作以及一些初始化前的准备工作，可以细分为三个步骤：验证、准备和解析。

**验证 Verification**

当一个类被加载之后，必须要验证一下这个类是否合法，比如这个类是不是符合字节码的格式、变量与方法是不是有重复、数据类型是不是有效、继承与实现是否合乎标准等等。总之，这个阶段的目的就是保证加载的类是能够被 JVM 所运行，并且不会危害虚拟机自身的安全，例如说数组越界访问。

**准备 Preparation**

准备阶段的工作就是为类的静态变量分配内存并设为 JVM 默认的初值，对于非静态的变量，则不会为它们分配内存，这些变量使用的内存都将在方法区中分配。有一点需要注意，这时候，静态变量的初值为 JVM 默认的初值，而不是我们在程序中设定的初值。JVM 默认的初值是这样的：

1. 基本类型(boolean, byte, short, char, int, long, float, double)的默认值为 0.
2. 引用类型的默认值为 `null`
3. 常量的默认值为我们程序中设定的值，比如我们在程序中定义 final static int a = 100，则准备阶段中 a 的初值就是100

**解析 Resolution**

这一阶段的任务就是把常量池中的符号引用转换为直接引用。

- 符号引用：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只有使用时能无歧义地定位到目标即可。此时目标不一定在内存中。
- 直接引用：直接引用可以是直接指向目标的指针，相对偏移量或者一个能间接定位到目标的句柄。此时目标已经在内存中。

连接阶段完成之后会根据使用的情况（主动引用还是被动引用）来选择是否对类进行初始化。

### 初始化 Initalization

类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了加载阶段用户应用程序可以通过自定义的类加载器参与之外，其余动作由虚拟机主导和控制。到了本阶段，才真正开始执行类中定义的代码。

初始化过程是执行类构造器 `<clinit>()` 方法的过程。`<clinit>()` 方法是由编译器自动收集类中所有类变量赋值操作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的。

静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。

1. 虚拟机保证父类的 `<clinit>()` 方法在子类的 `<clinit>()` 之前被执行。
2. 虚拟机保证 `<clinit>()` 在多线程环境中被正确地加锁，同步，同一个类加载器下，一个类 `<clinit>()` 方法只会被执行一次。

### 使用 Using

**主动引用**

如果一个类被主动引用，就会触发类的初始化。在 java 中，主动引用的情况有：

1. 通过 `new` 关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。
2. 通过反射方式执行以上三种行为。
3. 初始化子类的时候，会触发父类的初始化。
4. 作为程序入口直接运行时（也就是直接调用 main 方法）。

**被动引用**

1. 引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。
2. 定义类数组，不会引起类的初始化。
3. 引用类的常量，不会引起类的初始化。

### 卸载 Unloading

在类使用完之后，如果满足下面的情况，类就会被卸载：

1. 该类所有的实例都已经被回收，也就是 java 堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader 已经被回收。
3. 该类对应的 `java.lang.Class` 对象没有任何地方被引用，没有在任何地方通过反射访问该类的方法。

如果以上三个条件全部满足，JVM 就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java 类的整个生命周期就结束了。

由 Java 虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java 虚拟机自带的类加载器包括根类加载器、扩展类加载器和系统类加载器。Java 虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的 Class 对象，因此这些 Class 对象始终是可触及的。

由用户自定义的类加载器加载的类是可以被卸载的。

## 字节码

1. `invokestatic`: 用于调用静态方法。
2. `invokespecial`: 用于调用私有实例方法、构造器，以及使用 `super` 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
3. `invokevirtual`: 用于调用非私有实例方法。
4. `invokeinterface`: 用于调用接口方法。
5. `invokedynamic`: 用于调用动态方法。

# GC

JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。

其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。

而 Java 堆区和方法区则不一样，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。

垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！

**方法区回收**

方法区主要回收的内容有：废弃常量和无用的类。

对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面 3 个条件：

1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例；
2. 加载该类的 `ClassLoader` 已经被回收；
3. 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 垃圾回收算法

### 引用计数法

引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。

当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为 1。

当任何其它变量被赋值为这个对象的引用时，计数加 1（a = b, 则 b 引用的对象实例的计数器 +1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减 1。

任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。

**优缺点**

优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。

缺点：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为 0。

### 根搜索算法

(可达性分析算法)

可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点 GC ROOT 开始，寻找对应的引用节点

找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。

在 Java 语言中，可作为 GC Roots 的对象包括下面几种：

- 虚拟机栈中引用的对象（栈帧中的本地变量表）；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中 JNI（Native 方法）引用的对象。

**标记-清除算法**

标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记

标记完毕后，再扫描整个空间中未被标记的对象，进行回收

标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效

但由于标记-清除算法直接回收不存活的对象，因此会造成*内存碎片*

**复制算法**

复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。

它开始时把堆分成 一个对象面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于 copying 算法的垃圾收集就从根集合（GC Roots）中扫描活动对象，并将每个活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)

这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。

**标记-整理算法**

标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。

标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。

**分代收集算法**

分代收集算法是目前大部分 JVM 的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。

一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。

老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

- 年轻代（Young Generation）的回收算法

a) 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。

b) 新生代内存按照 8:1:1 的比例分为一个 eden 区和两个 survivor(survivor0,survivor1) 区。

大部分对象在 Eden 区中生成，回收时先将 eden 区存活对象复制到一个 survivor0 区，然后清空 eden 区。

当这个 survivor0 区也存放满了时，则将 eden 区和 survivor0 区存活对象复制到另一个 survivor1 区，然后清空 eden 和这个 survivor0 区，此时 survivor0 区是空的

然后将 survivor0 区和 survivor1 区交换，即保持 survivor1 区为空， 如此往复。

c) 当 survivor1 区不足以存放 eden 和 survivor0 的存活对象时，就将存活对象直接存放到老年代。

若是老年代也满了就会触发一次 Full GC，也就是新生代、老年代都进行回收。

d) 新生代发生的 GC 也叫做 Minor GC，MinorGC 发生频率比较高(不一定等 Eden 区满了才触发)。

- 年老代（Old Generation）的回收算法

a) 在年轻代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。

因此，可以认为年老代中存放的都是一些生命周期较长的对象。

b) 内存比新生代也大很多(大概比例是 1:2)，当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率标记高。

- 持久代（Permanent Generation）的回收算法

用于存放静态文件，如 Java 类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class，例如 Hibernate 等，

在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。

持久代也称方法区

## 垃圾回收器

收集器|串行/并行/并发|新/老|算法|目标|适用场景
:---:|:---:|:---:|:---:|:---|:---
Serial|串行|新生代|复制算法|响应速度优先|单 CPU 环境下的 Client 模式
Serial Old|串行|老年代|标记-整理|响应速度优先|单 CPU 环境下的 Client 模式、CMS 的后备预案
ParNew|并行|新生代|复制算法|响应速度优先|多 CPU 环境时在 Server 模式下与 CMS 配合
Parallel Scavenge|并行|新生代|复制算法|吞吐量优先|在后台运算而不需要太多交互的任务
Parallel Old|并行|老年代|标记-整理|吞吐量优先|在后台运算而不需要太多交互的任务
CMS|并发|老年代|标记-清除|响应速度优先|集中在互联网站或 B/S 系统服务端上的 Java 应用
G1|并发|both|标记-整理+复制算法|响应速度优先|面向服务端应用，将来替换CMS

### Serial

工作模式

```bash
      User Thread 1 |            |         |            |
CPU 0 ------------> |            | ------> |            | --->
      User Thread 2 | GC Thread  |         | GC Thread  |
CPU 1 ------------> | ---------> | ------> | ---------> | --->
      User Thread 3 |            |         |            |
CPU 2 ------------> |            | ------> |            | --->
      User Thread 4 |            |         |            |
CPU 3 ------------> | New        | ------> | Old        | --->
                SafePoint              SafePoint
```

**新生代 Serial**

1. 单线程
2. 标记-复制算法
3. 暂停所有用户线程

**老年代 Serial Old**

1. 单线程
2. 标记-整理算法
3. 暂停所有用户线程
4. 主要用于 Client 模式下的虚拟机使用

### ParNew

工作模式

```bash
      User Thread 1 |              |         |            |
CPU 0 ------------> |              | ------> |            | --->
      User Thread 2 | GC Thread 1  |         | GC Thread  |
CPU 1 ------------> | -----------> | ------> | ---------> | --->
      User Thread 3 |              |         |            |
CPU 2 ------------> | GC Thread 2  | ------> |            | --->
      User Thread 4 | -----------> |         |            |
CPU 3 ------------> | New          | ------> | Old        | --->
                SafePoint              SafePoint
```

Parnew 是 Serial 收集器的**多线程**版本，也是**新生代**收集器。ParNew 收集器和 Serial 收集器除了多线程工作外几乎是相同的，包括所有控制参数、收集算法、stop the world，对象分配规则，回收策略等都是一样的。

虽然与 Serial 收集器相比仅仅多了多线程特性外，没有其它的创新之处，但是它却是许多 Server 模式下的虚拟机新生代收集器的首选，原因在于目前为止只有 Serial 和 ParNew 两个新生代收集器能够与性能优异的 CMS 配合使用。更加注重吞吐率。

### Parallel Scavenge

Parallel Scavenge 也是一款使用多线程**复制算法**的新生代收集器。该收集器与其它收集器不同的是，它关注的目标是达到一个可控制的吞吐量，而 CMS 等收集器的关注点则是尽可能地减少用户线程地停顿时间，提高用户体验。Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的 `-XX:MaxGCPauseMillis` 参数以及直接设置吞吐量大小的 `-XX:GCTimeRatio` 参数。也因此，Parallel Scavenge 被成为 “吞吐量优先” 收集器。

停顿时间越短就越适合与用户交互较多地程序，这样用户体验才更好。而高吞吐量则可以让出更多的 cpu 资源给用户线程，让程序更快的完成运算任务，更适合后台运算较多而不需要与用户交互的程序。

自适应调节策略是 Parallel Scavenge 收集器的特点，也是与 ParNew 收集器的区别。Parallel Scavenge 通过打开 `-XX:+UseAdaptiveSizePolicy` 的设置，就不需要手动地调节新生代（`-Xmn`）大小，Eden 和Survivor 区的比例（`-XX:SurvivorRatio`）、晋升老年代对象年龄（`-XX:PretenureSizeThreshold`）等细节参数，而是根据当前系统运行情况来确定这些参数，从而提高程序地吞吐量和缩短停顿时间，这一过程称之为 GC 自适应的调节策略（GC Ergonomics）。

另外值得注意的一点是，Parallel Scavenge 无法已 CMS 配合使用，如果新生代选择了 Parallel Scavenge 收集器，那么老年代的收集器只能选用 Serial Old 或者 Parallel Old 来配置使用。

### Parallel Old

工作模式

```bash
      User Thread 1 |              |         |              |
CPU 0 ------------> |              | ------> |              | --->
      User Thread 2 | GC Thread 1  |         | GC Thread 1  |
CPU 1 ------------> | -----------> | ------> | -----------> | --->
      User Thread 3 |              |         |              |
CPU 2 ------------> | GC Thread 2  | ------> | GC Thread 1  | --->
      User Thread 4 | -----------> |         | -----------> |
CPU 3 ------------> | New          | ------> | Old          | --->
                SafePoint                SafePoint
```

Parallel Old 是 Parallel Scavenge 的老年代版本，也是一个并行收集器，使用 “标记-整理” 算法。该收集器在 jdk1.6 后对外提供使用，Parallel Scavenge 和  Parallel Old 配合使用的话，更加适合应用于**高吞吐量**和 cpu 敏感资源的场合。

### CMS

工作模式

```bash
      User Thread 1 |         |              |         |              |
CPU 0 ------------> |         |              |         |              | 
      User Thread 2 |         | User Thread  | Step 3  | User Thread  | User Thread
CPU 1 ------------> | Step 1  | -----------> | ------> | -----------> | ----------->
      User Thread 3 | ------> |              |         |              |
CPU 2 ------------> |         |    Step 2    | Step 3  |    Step 4    |   重置线程
      User Thread 4 |         | -----------> | ------> | -----------> | ----------->
CPU 3 ------------> |         |              |         |              | 
                SafePoint SafePoint      SafePoint SafePoint      SafePoint
```

CMS（Concurrent Mark Sweep）是一个老年代**并发**收集器，使用了 “标记-清除” 算法来实现的。该收集器最求的更短的停顿时间，从而提升用户体验，因此也非常符合使用在网站、B/S 系统的服务端的应用。

CMS 收集器的工作流程大概可以分为以下 4 个步骤：

- Step 1 初始标记：这个阶段仅仅标记能够和 gc roots 直接关联的对象，速度很快，但是需要 “stop the world”。
- Step 2 并发标记：这个阶段开始进行 gc roots tracing 标记，与用户线程一起执行的，消耗时间很多。
- Step 3 重新标记：这个阶段是要是修正在并发标记期间由于用户线程也在运行而产生标记变动的那部分对象的标记，比较耗费的时间比初始标记阶段要长，但是远比并发标记阶段要短，这个过程也是需要 “stop the world” 的。
- Step 4 并发清除：对无用对象进行回收操作。这个过程与用户线程并行执行。

由于标记和清除阶段可以和用户线程一起工作，因此几乎可以把CMS收集器的工作是并发的：

CMS是一款优秀的收集器，它的主要优点是低停顿，并发收集，因此也被成为并发低停顿收集器（Concurrent Low Pause Collector）。

当然，CMS收集器也有一定的缺点，主要包括一下几点：

1. CMS 收集器使用 “标记-清除” 算法实现，因此不可避免地有内存碎片地问题。当内存碎片过多时，在分配大对象地过程中即使有足够的空间，但是找不到足够地连续的空间来放该对象，那么就有可能触发一次 full gc。
2. 无法处理浮动垃圾（Floating Garbage） 可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。这是因为在标记的过程中用户线程也在运行着，那么在这一过程中出现的垃圾无法立即回收，而是等下一次 gc 才能清理，我这部分的垃圾就叫做 “浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。
3. 对 cpu 资源非常敏感。其实，只要是面对并发的情况下都会有这个问题，在并发阶段虽然不会中断用户线程，但是因为占用了部分用户的资源而导致程序变慢，总吞吐量降低。CMS 搜集器默认的线程数 = （cpu核数 + 3） / 4，当 cpu 数量大于 4 时，垃圾回收线程数不少于 25%，随着线程数的增加而下降，当 cpu 数量小于 4 时对线程的执行效率有显著的影响。

[好文推荐：CMS学习笔记！！！](https://mp.weixin.qq.com/s/-yqJa4dOyzLaK_tJ1x9E7w)<br>

### G1

G1 (Garbage First) 是一个横跨新生代和老年代的垃圾回收器。直接将堆分成极其多个区域，每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。采用 标记-压缩算法，而且和 CMS 一样都能够在应用程序运行过程并发地进行垃圾回收。优先回收死亡对象较多的区域。

G1（Garbage-First）是一款面向服务端应用的垃圾收集器，JDK 7 Update4 后开始进入商用。HotSpot 开发团队赋予它的使命是未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。之前提供的收集器都是仅作用于新生代或者是老年代，但是 G1 收集器可以作用于新生代和老年代，因为使用 G1 收集器是 java heap 的内存结构有很大的不同，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但是他们已经没有了物理上的隔阂了，它们都是 region 的一部分的集合。

G1 收集器是当今收集器技术发展的最前沿成果之一，与其他收集器相比，G1 收集器具有以下特征：

- 并行与并发： G1 能充分利用多 CPU，多核环境下的硬件优势，使用多个 CPU 来缩短 Stop-The-World 停顿时间，部分其他收集器原本需要停顿 java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- 分代收集： 与其他收集器一样，分代概念在 G1 中仍然得以保留。虽然 G1 可以不需要其他收集器配合能够独立管理整个堆，但它能够采用不用的方式去处理新创的对象和已经存活了一段世纪那、熬过多次 GC 的旧对象以获得更好的收集效果。
- 空间整合： 与 CMS 的 “标记-清除” 算法不同，G1 整体来看采用了 “标记-整理” 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 “复制” 算法实现的。无论使用哪一种方法，都意味着 G1 运作期间不会产生内存空间碎片的问题，收集后能提供规整的可用空间。这种特性有利于程序长时间运行，分配大对象是不会因为无法得到连续内存空间而提前处罚一次 GC。
- 可预测的停顿： 这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了最求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒，这几乎是 java（RTSJ）的垃圾收集器的特征了。

G1 收集器之所以能够建立可预测的停顿时间模型，因为他能够有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要的经验值），在后台维护一个优先表，每次根据允许的收集时间，优先回收价值最大的 Region。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。

在 G1 收集器中，Region 之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用，虚拟机都是使用 Remembered Set 来避免全堆扫描的。G1 中每个 Region 都有一个与之对应的 Remembered Set，虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 中，如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 中的 Remembered Set 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描，也不会有遗漏。

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致分为以下几个步骤：

1. 初始标记（Initial Marking）： 这阶段仅仅只是标记 GC Roots 能直接关联到的对象并修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确的可用的 Region 中创建新对象，这阶段需要停顿线程，但是耗时很短。
2. 并发标记（Concurrent Marking）： 从 GC Roots 开始对堆的对象进行可达性分析，找出存活的对象，这阶段耗时长，但是可以与用户程序并发执行。
3. 最终标记（Final Marking）： 为了修正在并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录记录在线程 Remembered Set Logs 里面。
4. 筛选回收（Live Data Counting and Evacuation）： 首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，这一阶段是可以与用户程序一起并发执行的，但是因为只回收部分 Region，时间是用户可控的，而且停顿用户线程将大幅度提高收集效率。

[好文推荐：G1学习笔记！！！](https://mp.weixin.qq.com/s/CG-k-Vqw3LVUyUjnDpPmFw)<br>