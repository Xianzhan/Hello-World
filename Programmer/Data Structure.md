<!-- TOC -->

- [数据结构](#数据结构)
- [线性表](#线性表)
    - [数组](#数组)
    - [链表](#链表)
        - [链表应用场景](#链表应用场景)
    - [栈](#栈)
        - [栈应用场景](#栈应用场景)
    - [队列](#队列)
        - [阻塞队列](#阻塞队列)
        - [并发队列](#并发队列)
- [资源](#资源)

<!-- /TOC -->

# 数据结构

数据结构就是指一组数据的存储结构, 是为算法服务的.

![](../.resource/Programmer-Data%20Structure-brain_map.png)

# 线性表

## 数组

**特性**: 连续的内存空间和相同类型的数据.

对 CPU 缓存友好, 可以有效预读.

为什么大多数编程语言中, 数组下标要从 0 开始编号, 而不是从 1 开始呢?

从数组存储的内存模型上来看, "下标" 最确切的定义应该是 "偏移(offset)". arr[0] 就是偏移为 0 的位置.

## 链表

类型|数组|链表
:---:|:---:|:---:
插入删除|O(n)|O(1)
随机访问|O(1)|O(n)

与数组相比, 无需像数组那样需要申请连续的内存空间, 它通过 "指针" 将一组零散的内存块串联起来使用.

### 链表应用场景

LRU 缓存淘汰算法

1. 如果此数据之前已经被缓存在链表中, 我们遍历得到这个数据对应的节点, 并将其从原来的位置删除, 然后再插入到链表的头部.
2. 如果此数据没有在缓存链表中, 又可以分为两种情况:
    - 如果此时缓存未满, 则将此节点直接插入到链表的头部;
    - 如果此时缓存已满, 则链表尾节点删除, 将新的数据节点插入链表的头部.

缓存是一种提高数据读取性能的技术, 在硬件设计、软件开发中都有非常广泛的应用, 比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等.

## 栈

从栈的操作特性上来看, 栈是一种 "操作受限" 的线性表, 只允许在一端插入和删除数据.

用数组实现的栈叫做顺序栈, 用链表实现的栈叫作链式栈.

### 栈应用场景

1. 函数调用栈
2. 编译器利用栈来实现表达式求值
3. 浏览器的前进和后退, 使用两个栈

## 队列

先进者先出.

用数组实现的队列叫作顺序队列, 用链表实现的队列叫作链式队列.

### 阻塞队列

- 在队列为空的时候, 从队头取数据会被阻塞, 直到队列中有了数据才能返回;
- 如果队列已经满了, 那么插入数据的操作就会被阻塞, 直到队列中有空闲位置后再插入数据.

### 并发队列

线程安全的队列我们叫作并发队列.

基于链表的实现方式, 可以实现一个支持无限排队的无界队列(unbounded queue), 但是可能会导致过多的请求排队等待, 请求处理的响应时间过长. 所以, 针对响应时间比较敏感的系统, 基于链表实现的无限排队的线程池是不合适的.

基于数组实现的有界队列(bounded queue), 队列的大小有限, 所以线程池中排队的请求超过队列大小时, 接下来的请求就会被拒绝, 这种方式对响应时间敏感的系统来说, 就相对更加合理. 不过, 设置一个合理的队列大小, 也是非常有讲究的. 队列太大导致等待的请求太多, 队列太小会导致无法充分利用系统资源, 发挥最大性能.

# 资源

<大话数据结构><br>