<!-- TOC -->

- [数据结构](#数据结构)
- [线性表](#线性表)
    - [数组](#数组)
    - [链表](#链表)
    - [栈](#栈)
    - [队列](#队列)
        - [阻塞队列](#阻塞队列)
        - [并发队列](#并发队列)
    - [跳表(skip list)](#跳表skip-list)
    - [散列表](#散列表)
        - [散列冲突](#散列冲突)
- [树](#树)
    - [二叉树](#二叉树)
        - [满二叉树](#满二叉树)
        - [完全二叉树](#完全二叉树)
        - [二叉查找树](#二叉查找树)
        - [平衡二叉树](#平衡二叉树)
        - [平衡二叉查找树](#平衡二叉查找树)
            - [AVL 树](#avl-树)
            - [红黑树](#红黑树)
    - [堆](#堆)
- [资源](#资源)

<!-- /TOC -->

# 数据结构

数据结构就是指一组数据的存储结构, 是为算法服务的.

![](../.resource/Programmer-Data%20Structure-brain_map.png)

# 线性表

## 数组

**特性**: 连续的内存空间和相同类型的数据.

对 CPU 缓存友好, 可以有效预读.

为什么大多数编程语言中, 数组下标要从 0 开始编号, 而不是从 1 开始呢?

从数组存储的内存模型上来看, "下标" 最确切的定义应该是 "偏移(offset)". arr[0] 就是偏移为 0 的位置.

## 链表

类型|数组|链表
:---:|:---:|:---:
插入删除|O(n)|O(1)
随机访问|O(1)|O(n)

与数组相比, 无需像数组那样需要申请连续的内存空间, 它通过 "指针" 将一组零散的内存块串联起来使用.

应用场景

LRU 缓存淘汰算法

1. 如果此数据之前已经被缓存在链表中, 我们遍历得到这个数据对应的节点, 并将其从原来的位置删除, 然后再插入到链表的头部.
2. 如果此数据没有在缓存链表中, 又可以分为两种情况:
    - 如果此时缓存未满, 则将此节点直接插入到链表的头部;
    - 如果此时缓存已满, 则链表尾节点删除, 将新的数据节点插入链表的头部.

缓存是一种提高数据读取性能的技术, 在硬件设计、软件开发中都有非常广泛的应用, 比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等.

## 栈

从栈的操作特性上来看, 栈是一种 "操作受限" 的线性表, 只允许在一端插入和删除数据.

用数组实现的栈叫做顺序栈, 用链表实现的栈叫作链式栈.

应用场景

1. 函数调用栈
2. 编译器利用栈来实现表达式求值
3. 浏览器的前进和后退, 使用两个栈

## 队列

先进者先出.

用数组实现的队列叫作顺序队列, 用链表实现的队列叫作链式队列.

### 阻塞队列

- 在队列为空的时候, 从队头取数据会被阻塞, 直到队列中有了数据才能返回;
- 如果队列已经满了, 那么插入数据的操作就会被阻塞, 直到队列中有空闲位置后再插入数据.

### 并发队列

线程安全的队列我们叫作并发队列.

基于链表的实现方式, 可以实现一个支持无限排队的无界队列(unbounded queue), 但是可能会导致过多的请求排队等待, 请求处理的响应时间过长. 所以, 针对响应时间比较敏感的系统, 基于链表实现的无限排队的线程池是不合适的.

基于数组实现的有界队列(bounded queue), 队列的大小有限, 所以线程池中排队的请求超过队列大小时, 接下来的请求就会被拒绝, 这种方式对响应时间敏感的系统来说, 就相对更加合理. 不过, 设置一个合理的队列大小, 也是非常有讲究的. 队列太大导致等待的请求太多, 队列太小会导致无法充分利用系统资源, 发挥最大性能.

## 跳表(skip list)

链表加多级索引的结构.

1. redis 的有序集合(sorted set)

## 散列表

散列表用的是数组支持按照下标随机访问数据的特性, 所以散列表其实就是数组的一种扩展, 由数组演化而来. 可以说, 如果没有数组, 就没有散列表.

1. word 文档中单词的拼写检查功能.

### 散列冲突

解决方法:

1. 开放寻址法(open addressing)

如果出现散列冲突, 就重新探测一个空闲位置, 将其插入.

2. 链表法(chaining)

如果出现散列冲突, 则冲突位置转为一个链表记录. 如果散列算法不好, 则时间复杂度变为 O(n).

# 树

## 二叉树

概念: 高度(height)、深度(depth)、层(level)

- 节点的高度 = 节点到叶子节点的最长路径
- 节点的深度 = 根节点到这个节点所经历的边的个数
- 节点的层数 = 节点的深度 + 1
- 树的高度 = 根节点的高度

遍历

- 前序遍历: 对于树中的任意节点, 先打印这个节点, 然后再打印它的左子树, 最后打印它的右子树.
- 中序遍历: 对于树中的任意节点, 先打印它的左子树, 然后再打印它本身, 最后打印它的右子树.
- 后序遍历: 对于树中的任意节点, 先打印它的左子树, 然后再打印它的右子树, 最后打印这个节点本身.

### 满二叉树

叶子节点都在最底层, 除了叶子节点之外, 每个节点都有左右两个子节点.

### 完全二叉树

叶子节点都在最底下两层, 最后一层的叶子节点都靠左排列, 并且除了最后一层, 其它层的节点个数都要达到最大.

1. 堆是一种完全二叉树, 最常用的存储方式就是数组.

### 二叉查找树

也叫二叉搜索树, 是为实现快速查找而生的. 不仅仅支持快速查找一个数据, 还支持快速插入、删除一个数据.

特性:

1. 左子树的值一定小于当前节点的值, 而右子树的值都大于这个节点的值.

### 平衡二叉树

二叉树中任意一个节点的左右子树的高度相差不能大于 1. 完全二叉树和满二叉树都是平衡二叉树.

### 平衡二叉查找树

#### AVL 树

任何节点的左右子树高度相差不超过 1, 是一种高度平衡的二叉查找树.

AVL 树是一种高度平衡的二叉树, 所以查找的效率非常高, 但是, 每次插入、删除都要做调整.

#### 红黑树

红黑树的插入、删除、查找各种操作性能都比较稳定.

特性:

1. 根节点是黑色的
2. 每个叶子节点都是黑色的空节点, 也就是说, 叶子节点不存储数据
3. 任何相邻的节点都不能同时为红色, 也就是说, 红色节点是被黑色节点隔开的
4. 每个节点, 从该节点到达其可达叶子节点的所有路径, 都包含相同数目的黑色节点

## 堆

堆适合使用数组来实现.

特性:

1. 堆是一个完全二叉树
2. 堆中每一个节点的值都必须大于等于(或小于等于)其子树中的每个节点的值.

使用场景:

1. 优先级队列
2. 利用堆求 Top K
3. 求中位数

# 资源

<大话数据结构><br>