<!-- TOC -->

- [算法](#算法)
    - [复杂度分析](#复杂度分析)
        - [大 O 复杂度表示法](#大-o-复杂度表示法)
- [基本思想](#基本思想)
    - [分治](#分治)
        - [递归](#递归)
- [排序](#排序)
    - [冒泡排序](#冒泡排序)
    - [插入排序](#插入排序)
    - [选择排序](#选择排序)
    - [归并排序](#归并排序)
    - [快速排序](#快速排序)
    - [桶排序](#桶排序)
    - [计数排序](#计数排序)
    - [基数排序](#基数排序)
    - [堆排序](#堆排序)
- [查找](#查找)
    - [二分查找](#二分查找)
- [搜索](#搜索)
    - [广度优先搜索(BFS)](#广度优先搜索bfs)
    - [深度优先搜索(DFS)](#深度优先搜索dfs)
- [消息摘要](#消息摘要)
    - [哈希算法](#哈希算法)
- [字符串匹配](#字符串匹配)
    - [BF 算法](#bf-算法)
    - [RK 算法](#rk-算法)
    - [BM 算法](#bm-算法)
- [资源](#资源)

<!-- /TOC -->

# 算法

算法就是操作数据的一组方法, 作用在特定的数据结构之上.

![](../.resource/Programmer-Algorithm-brain_map.png)

## 复杂度分析

复杂度分析是整个算法学习的精髓, 只要掌握了它, 数据结构和算法的内容基本上就掌握了一半.

### 大 O 复杂度表示法

大 O 时间复杂度实际上并不具体表示代码真正的执行时间, 而是表示**代码执行时间随数据规模增长的变化趋势**, 所以, 也叫作**渐进时间复杂度**(asymptotic time complexity), 简称**时间复杂度**.

**多项式量级**

- 常量阶 O(1)

一般情况下, 只要算法不存在循环语句、递归语句, 即使有成千上万行的代码, 其时间复杂度也是 O(1).

```java
int i = 1;
int j = 2;
int sum = i + j;
```

- 对数阶 O(logn)

```java
int i = 1;
while (i <= n) {
    i = i * 2;
}
```

- 线性阶 O(n)

```java
int i = 0;
while (i < n) {
    i++;
}
```

- 线性对数阶 O(nlogn)
- 平方阶 O(n^2)、立方阶 O(n^3)、k 次方阶 O(n^k)

**非多项式量阶**

- 指数阶 O(2^n)
- 阶乘阶 O(n!)

# 基本思想

## 分治

### 递归

分治是一种解决问题的处理思想, 递归是一种编程技巧.

**递归需要满足的三个条件**

1. 一个问题的解可以分解为几个子问题的解.
2. 这个问题与分解之后的子问题, 除了数据规模不同, 求解思路完全一样.
3. 存在递归终止条件.

*递归代码要警惕栈溢出*, *递归代码要警惕重复计算*

# 排序

排序算法|时间复杂度|稳定|原地
:---:|:---:|:---:|:---:
冒泡排序|O(n^2)|✔|✔
插入排序|O(n^2)|✔|✔
选择排序|O(n^2)|×|✔
快速排序|O(nlogn)|×|✔
归并排序|O(nlogn)|✔|×
计数排序|O(n+k)k是数据范围|✔|×
桶排序|O(n)|✔|×
基数排序|O(dn)d是维度|✔|×


## 冒泡排序

冒泡排序只会操作相邻的两个数据. 每次冒泡至少会让一个元素移动到它应该在的位置.

## 插入排序

将数据分为两个区间, 已排序区间和未排序区间. 取未排序区间的元素, 在已排序区间中找到合适的插入位置将其插入.

## 选择排序

选择排序算法的实现思路有点类似插入排序, 也分已排序区间和未排序区间. 但是选择排序每次会从未排序区间找到最小元素, 将其放到已排序区间的末尾.

## 归并排序

先把数组从中间分成前后两部分, 然后对前后两部分分别排序, 再将排好序的两部分合并在一起.

## 快速排序

将数据分为三部分, 第一部分是都比分割数据小的, 第二部分是分割数据, 第三部分是都比分割数据大的. 如此反复.

1. 从无序的数据里挑出第 K 大的位置

## 桶排序

首先, 排序的数据可以划分成 m 个桶, 并且, 桶与桶之间有着天然的大小顺序. 其次, 数据在各个桶之间的分布是比较均匀的.

**桶排序比较适合用在外部排序.**

## 计数排序

计数排序其实是桶排序的一种特殊情况. 当要排序的 n 个数据, 所处的范围并不大的时候, 比如最大值是 k, 我们可以把数据划分为 k 个桶, 每个桶内的数据值都是相同的, 省掉桶内排序的时间.

1. 计算高考分数的排名.

## 基数排序

基数排序对要排序的数据是有要求的，需要可以分割出独立的 “位” 来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了

1. 手机号排序
2. 英语字典单词排序

## 堆排序

堆排序对应的是数据结构是堆, 是一种原地的、时间复杂度为 O(nlogn) 的排序算法.

# 查找

## 二分查找

针对有序数据集合的查找算法.

# 搜索

## 广度优先搜索(BFS)

## 深度优先搜索(DFS)

# 消息摘要

## 哈希算法

将任意长度的二进制值串映射为固定长度的二进制串.

1. 安全加密
2. 唯一标识
3. 数据校验
4. 散列函数

**分布式相关**

5. 负载均衡
6. 数据分片
7. 分布式存储

# 字符串匹配

## BF 算法

Brute Force 的缩写, 中文叫作暴力匹配算法, 也叫朴素匹配算法.

简单场景, 主串和模式串都不太长, O(m*n)

## RK 算法

RK 算法的全称叫 Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的.

计算子串与部分主串的哈希值是否一致.

## BM 算法

Boyer-Moore 算法

# 资源

[GitHub://LeetCodeAnimation](https://github.com/MisterBooo/LeetCodeAnimation)<br>
[GitHub://javascript-algorithms](https://github.com/trekhleb/javascript-algorithms)<br>
<算法图解><br>