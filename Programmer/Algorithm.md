<!-- TOC -->

- [算法](#算法)
    - [复杂度分析](#复杂度分析)
        - [大 O 复杂度表示法](#大-o-复杂度表示法)
    - [复杂度速查表](#复杂度速查表)
- [资源](#资源)

<!-- /TOC -->

# 算法

算法就是操作数据的一组方法, 作用在特定的数据结构之上.

![](../.resource/Programmer-Algorithm-brain_map.png)

## 复杂度分析

复杂度分析是整个算法学习的精髓, 只要掌握了它, 数据结构和算法的内容基本上就掌握了一半.

### 大 O 复杂度表示法

大 O 时间复杂度实际上并不具体表示代码真正的执行时间, 而是表示**代码执行时间随数据规模增长的变化趋势**, 所以, 也叫作**渐进时间复杂度**(asymptotic time complexity), 简称**时间复杂度**.

**多项式量级**

- 常量阶 O(1)

一般情况下, 只要算法不存在循环语句、递归语句, 即使有成千上万行的代码, 其时间复杂度也是 O(1).

```java
int i = 1;
int j = 2;
int sum = i + j;
```

- 对数阶 O(logn)

```java
int i = 1;
while (i <= n) {
    i = i * 2;
}
```

- 线性阶 O(n)

```java
int i = 0;
while (i < n) {
    i++;
}
```

- 线性对数阶 O(nlogn)
- 平方阶 O(n^2)、立方阶 O(n^3)、k 次方阶 O(n^k)

**非多项式量阶**

- 指数阶 O(2^n)
- 阶乘阶 O(n!)

## 复杂度速查表

|排序名称|比较次数|赋值交换次数|时间复杂度|时间复杂度最好|时间复杂度最坏|空间复杂度|稳定|特点|衍生算法|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|插入排序|N-1 到 N(N-1)/2|O(N^2)|O(N^2)|O(N)|O(N^2)|O(1)|是|简单稳定, 适合初始有序|希尔排序|
|选择排序|N(N-1)/2|O(N)|O(N^2)|O(N^2)|O(N^2)|O(1)|否|简单|双向选择排序|
|冒泡排序|N-1 到 N(N-1)/2|O(N^2)|O(N^2)|O(N)|O(N^2)|O(1)|是|简单稳定, 效率低|鸡尾酒排序|
|希尔排序|N-1 到 N(N-1)/2|O(N^2)|O(N^2)|O(N)|O(N^2)|O(1)|否|效率中等|无|
|堆排序|小于 2NlgN|O(NlgN)|O(NlgN)|O(NlgN)|O(NlgN)|O(1)|否|效率高占内存小, 缓存命中低|多叉堆排序|
|归并排序|NlgN 到 (2N-1)lgN|O(N)|O(NlgN)|O(NlgN)|O(NlgN)|O(N)|是|效率高稳定|多路归并排序|
|快速排序|NlgN 到 N(N-1)/2|O(NlgN)|O(NlgN)|O(NlgN)|O(N^2)|O(lgN)|否|效率高不稳定|三向快速排序|

# 资源

<算法图解><br>