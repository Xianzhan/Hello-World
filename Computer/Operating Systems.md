<!-- TOC -->

- [基础](#基础)
    - [操作系统的介绍](#操作系统的介绍)
    - [操作系统的类型](#操作系统的类型)
    - [启动计算机](#启动计算机)
- [系统结构](#系统结构)
    - [操作系统中的微内核](#操作系统中的微内核)
    - [操作系统中的内核 I/O 子系统](#操作系统中的内核-io-子系统)
    - [整体内核和与微内核的主要区别](#整体内核和与微内核的主要区别)
    - [系统调用介绍](#系统调用介绍)

<!-- /TOC -->

# 基础

## 操作系统的介绍

**操作系统的定义**

- 操作系统是控制应用程序执行的程序，并充当计算机用户和计算机硬件之间的接口。
- 一个更常见的定义是，操作系统是始终在计算机上运行的一个程序（通常称为内核），而其他所有程序都是应用程序。
- 操作系统与资源和服务（例如内存，处理器，设备和信息）的分配有关。操作系统相应地包括用于管理这些资源的程序，例如流量控制器，调度程序，内存管理模块，I/O 程序和文件系统。

**操作系统的功能**

1. 便利性：OS 使计算机更易于使用。
2. 效率：OS 允许高效使用计算机系统资源。
3. 进化能力：操作系统的构建方式应允许有效地开发，测试和引入新的系统功能，同时又不干扰服务。

每台通用计算机均由硬件，操作系统，系统程序和应用程序组成。硬件包括内存，CPU，ALU 和 I/O 设备，外围设备和存储设备。系统程序由编译器，装载程序，编辑器，OS 等组成。应用程序由业务程序，数据库程序组成。

![https://media.geeksforgeeks.org/wp-content/uploads/os.png](../.resource/Computer/Operating%20Systems/os.png)

每台计算机都必须具有操作系统才能运行其他程序。它执行基本任务，例如识别键盘输入，跟踪磁盘上的文件和目录，将输出发送到显示屏以及控制外围设备。

操作系统旨在满足两个基本目的：

1. 它控制着各种用户和任务之间计算系统资源的分配和使用。
2. 它提供了计算机硬件和编程器之间的接口，可简化应用程序的编码，创建，调试并使之可行。

操作系统必须支持以下任务。任务是：

1. 提供使用编辑器创建，修改程序和数据文件的功能。
2. 访问编译器以将用户程序从高级语言转换为机器语言。
3. 提供一个加载程序，将编译后的程序代码移至计算机的内存中以执行。
4. 提供处理 I/O 编程细节的例程。

**I/O 系统管理**

跟踪设备状态的模块称为 I/O 流量控制器。每个 I/O 设备都有一个设备处理程序，该处理程序位于与该设备关联的单独进程中。

I/O 子系统包括:

- 一个内存管理组件，包括缓冲缓存和后台处理。
- 通用设备驱动程序接口。

**汇编器**

程序员可以编写汇编程序，机器通过硬件解释某些基本指令。他将通过编写一系列的 `1` 和 `0`（机器语言）来对这台计算机进行编程，然后将它们放入机器的内存中。

**编译器**

高级语言，例如 FORTRAN，COBOL，ALGOL 和 PL/I，由编译器和解释器处理。编译器是接受 “高级语言” 源程序并生成相应目标程序的程序。解释器是一种看起来像在执行机器语言一样执行源程序的程序。通常使用相同的名称（FORTRAN，COBOL 等）来指定编译器及其关联语言。

**加载器**

加载器是一种加载目标程序并准备执行的例程。有多种加载方案：绝对加载，重定位和直接链接。通常，加载器必须加载，重定位和链接目标程序。加载器是一种程序，可将程序放入内存并为执行做好准备。在一个简单的加载方案中，汇编程序在辅助设备上输出程序的机器语言翻译，然后加载器将其放在内核中。加载器将用户程序的机器语言版本存储到内存中，并将控制权转移给该程序。由于加载程序比汇编程序小得多，使得用户程序可以使用更多核心。

**操作系统的历史**

代|年|电子设备|类型
:---:|:---|:---|:---
第一|1945-1955|真空管|插板
第二|1955-1965|晶体管|批处理系统
第三|1965-1980|集成电路(IC)|多任务
第四|1980-~|大规模集成电路|PC

## 操作系统的类型

- 批处理操作系统 - 计算机上程序中的作业序列，无需人工干预。
- 分时操作系统 - 允许许多用户共享计算机资源。（最大程度地利用资源）。
- 分布式操作系统 - 管理一组不同的计算机，使它们看起来像是一台计算机。
- 网络操作系统 - 在不同操作系统中运行的计算机可以参与公共网络（用于安全目的）。
- 实时操作系统 – 意味着应按时完成的应用程序。

如: 

- Windows（基于 GUI 的 PC）
- GNU/Linux（个人，工作站，ISP，文件和打印服务器，三层客户端/服务器）
- macOS（Macintosh），用于 Apple 的个人计算机和工作站（MacBook，iMac）。
- Android（用于智能手机/平板电脑/智能手表的 Google 操作系统）
- iOS（Apple 的 iPhone，iPad 和 iPod Touch 操作系统）

**批处理系统**

这种类型的操作系统不会直接与计算机交互。有一个操作员接受具有相同要求的相似工作并将其分组。操作员有责任对具有类似需求的工作进行分类。

![https://media.geeksforgeeks.org/wp-content/uploads/BatchOS.jpeg](../.resource/Computer/Operating%20Systems/batch_os.jpeg)

批处理操作系统的优点：

- 很难猜测或知道完成任何工作所需的时间。批处理系统的处理器知道队列中的作业要花多长时间
- 多个用户可以共享批处理系统
- 批处理系统的空闲时间非常少
- 在批处理系统中重复管理大型工作很容易

批处理操作系统的缺点：

- 批处理系统需要计算机操作员非常了解系统
- 批处理系统很难调试
- 如果任何作业失败，其他作业将不得不等待未知的时间

基于批处理的操作系统示例：薪资系统，银行对帐单等。

**分时操作系统**

每个任务都有一定的执行时间，以便所有任务都能顺利进行。每个用户使用单个系统时都会获得 CPU 时间。这些系统也称为多任务处理系统。该任务可以来自单个用户，也可以来自不同用户。每个任务执行的时间称为量子。在此时间间隔结束后，操作系统将切换到下一个任务。

![https://media.geeksforgeeks.org/wp-content/uploads/Time-Share.jpeg](../.resource/Computer/Operating%20Systems/time_share.jpeg)

分时操作系统的优势：

- 每个任务都有平等的机会
- 重复软件的机会更少
- 可以减少 CPU 空闲时间

分时操作系统的缺点：

- 可靠性问题
- 必须必须注意用户程序和数据的安全性和完整性
- 数据通讯问题

分时操作系统的示例包括：Multics，Unix 等。

**分布式操作系统**

这些类型的操作系统是计算机技术领域的最新进展，并且已被全世界广泛接受，并且步伐也很快。各种自主互连的计算机使用共享的通信网络相互通信。独立的系统拥有自己的存储单元和 CPU。这些被称为*松耦合系统*或分布式系统。这些系统的处理器在大小和功能上有所不同。使用这些类型的操作系统的主要好处是，总是有一个用户可以访问其系统上实际不存在的文件或软件，而可以访问此网络中连接的其他某些系统上的文件或软件。即在该网络中连接的设备中启用了远程访问。

![https://media.geeksforgeeks.org/wp-content/uploads/Distributed.jpeg](../.resource/Computer/Operating%20Systems/distributed.jpeg)

分布式操作系统的优势：

- 一个系统的故障不会影响另一网络的通信，因为所有系统都是相互独立的
- 电子邮件提高了数据交换速度
- 由于资源是共享的，因此计算非常快速且持久
- 主机上的负载减少
- 这些系统易于扩展，因为许多系统可以轻松添加到网络中
- 数据处理的延迟减少了

分布式操作系统的缺点：

- 主网络故障将停止整个通信
- 要建立分布式系统，所使用的语言还没有很好的定义
- 这些类型的系统非常昂贵，因此不易获得。不仅底层软件非常复杂并且尚未被很好地理解

分布式操作系统的示例是: LOCUS 等。

**网络操作系统**

这些系统在服务器上运行，并提供管理数据，用户，组，安全性，应用程序和其他联网功能的功能。这些类型的操作系统允许在小型专用网络上共享访问文件，打印机，安全性，应用程序和其他网络功能。网络操作系统的另一个重要方面是，所有用户都充分了解基础配置，网络中所有其他用户，他们各自的连接等），这就是为什么这些计算机通常被称为*紧密耦合系统*。

![https://media.geeksforgeeks.org/wp-content/uploads/Network-OS.jpeg](../.resource/Computer/Operating%20Systems/network_os.jpeg)

网络操作系统的优点：

- 高度稳定的集中式服务器
- 安全问题通过服务器处理
- 新技术和硬件升级很容易集成到系统中
- 可以从不同位置和类型的系统远程访问服务器

网络操作系统的缺点：

- 服务器价格昂贵
- 用户必须依靠中心位置进行大多数操作
- 定期需要维护和更新

网络操作系统的示例包括：Microsoft Windows Server 2003，Microsoft Windows Server 2008，UNIX，Linux，Mac OS X，Novell NetWare 和 BSD 等。

**实时操作系统**

这些类型的 OS 服务于实时系统。处理和响应输入所需的时间间隔很小。该时间间隔称为响应时间。

当对时间的要求非常严格时，可以使用实时系统，例如导弹系统，空中交通管制系统，机器人等。

两种类型的实时操作系统，如下所示：

- 硬实时系统：这些操作系统适用于时间限制非常严格的应用，即使最短的延迟也是不可接受的。这些系统是为挽救生命而设计的，例如自动降落伞或安全气囊，在发生任何事故时都必须随时可用。在这些系统中几乎找不到虚拟内存。
- 软实时系统：这些 OS 适用于时间限制不太严格的应用程序。

![https://media.geeksforgeeks.org/wp-content/uploads/RTOS.jpeg](../.resource/Computer/Operating%20Systems/RTOS.jpeg)

实时操作系统的优势：

- 最大消耗：设备和系统的最大利用率，因此所有资源的输出更多
- 任务转移：在这些系统中分配给任务的时间非常少。例如，在较旧的系统中，将一项任务转移到另一项任务大约需要10微秒，而在最新的系统中，则需要3微秒。
- 专注于应用程序：专注于运行应用程序，而对排队的应用程序不太重视。
- 嵌入式系统中的实时操作系统：由于程序的大小很小，因此 RTOS 也可以在嵌入式系统中使用，例如在传输系统和其他系统中。
- 无错误：这些类型的系统无错误。
- 内存分配：在此类系统中最好管理内存分配。

实时操作系统的缺点：

- 有限的任务：很少有同时运行的任务，并且很少集中在少数应用程序上以避免错误。
- 使用大量的系统资源：有时系统资源不是很好，而且也很昂贵。
- 复杂的算法：算法非常复杂，设计人员难以编写。
- 设备驱动程序和中断信号：需要特定的设备驱动程序和中断信号以最早响应中断。
- 线程优先级：设置线程优先级并不好，因为这些系统不太容易切换任务。

实时操作系统的示例包括：科学实验，医学成像系统，工业控制系统，武器系统，机器人，空中交通管制系统等。

## 启动计算机

打开计算机时，计算机要做的第一件事就是启动一个称为操作系统的特殊程序。操作系统的工作是通过处理控制计算机硬件的混乱细节来帮助其他计算机程序正常工作。

引导过程是每次您打开计算机时都会发生的事情。您真的看不到它，因为它发生的太快了。几分钟后，您按下电源按钮会回来，并且 Windows XP，Windows Vista 或您使用的任何操作系统都已加载。

BIOS 芯片告诉它在固定的位置进行查找，通常是在编号最小的硬盘（引导磁盘）上寻找特殊程序，称为引导加载程序（在 Linux 下，引导加载程序称为 Grub 或 LILO）。

**BIOS 功能**

POST（Power On Self Test）每次打开计算机时都会进行开机自检。听起来很复杂，那是因为确实如此。您的计算机在打开时会做很多事情，而这仅仅是其中的一部分。

它初始化各种硬件设备。这是重要的过程，以确保所有设备流畅运行而不会发生任何冲突。 ACPI 之后的 BIOS 创建表来描述计算机中的设备。

POST 首先检查 BIOS，然后测试 CMOS RAM。如果没有问题，则 POST 继续检查 CPU，硬件设备（例如视频卡），辅助存储设备（例如硬盘驱动器，软盘驱动器，Zip 驱动器或 CD/DVD 驱动器）。如果发现一些错误，则会在屏幕上显示错误消息或听到许多哔声。这些蜂鸣声称为 POST 蜂鸣声代码。

**主引导记录(Master Boot Record)**

主启动记录（MBR）是一个小程序，在计算机启动时启动，以查找操作系统（例如 Windows XP）。这个复杂的过程（称为引导过程）从 POST（开机自检）开始，并在 Bios 在硬盘上搜索 MBR 时结束，通常位于第一扇区，第一磁头，第一气缸（气缸0，磁头0，扇区1）中。

![https://media.geeksforgeeks.org/wp-content/uploads/mbr-2.png](../.resource/Computer/Operating%20Systems/mbr-2.png)

引导程序加载器存储在计算机的 EPROM，ROM 或其他非易失性存储器中。打开或重新启动计算机后，它将首先执行开机自检，也称为 POST。如果 POST 成功且未发现任何问题，则引导加载程序会将计算机的操作系统加载到内存中。然后，计算机将能够快速访问，加载和运行操作系统。

**init**

init 是内核引导序列的最后一步。它查找文件 /etc/inittab 以查看是否有 initdefault 的条目。它用于确定系统的初始运行级别。

- Level 0 -> System Halt
- Level 1 -> Single user mode
- Level 3 -> Full multiuser mode with network
- Level 5 -> Full multiuser mode with network and X display manager
- Level 5 -> Reboot

init 的下一步是启动支持网络和其他服务的各种守护程序。 X 服务器守护程序是最重要的守护程序之一。它管理显示，键盘和鼠标。启动 X 服务器守护程序时，您会看到图形界面并显示登录屏幕。

# 系统结构

## 操作系统中的微内核

内核是管理系统资源的操作系统的核心部分。它也像计算机的应用程序和硬件之间的桥梁。它是启动时（在Bootloader之后）加载的第一个程序之一。

CPU 仅在内核模式下才能执行某些指令。这些指令称为特权指令。它们允许执行特殊的操作，该特殊的操作由用户程序执行可以与操作系统的功能或另一个用户程序的活动进行交互。例如，用于管理内存保护的指令。

- 当操作系统在内核中执行时，操作系统将 CPU 置于内核模式，以便内核可以执行某些特殊操作。
- 当执行用户程序时，操作系统会将 CPU 置于用户模式，因此用户程序无法与操作系统程序进行接口。
- 用户级指令不需要特殊权限。例如 ADD，PUSH 等。

模式的概念可以扩展到两种以上，需要一个以上的模式位来支持虚拟化的 CPU 使用这些额外的位中的一个来指示何时由虚拟机管理器 VMM 控制系统。VMM 具有比普通用户程序更多的特权，但没有完整的内核那么多。

系统调用通常以软件中断的形式实现，这会导致硬件的中断处理程序将控制权转移到适当的中断处理程序，这是操作系统的一部分，在此过程中将模式位切换为内核模式。中断处理程序会准确检查生成了哪个中断，检查适当的其他参数（通常通过寄存器传递），然后调用适当的内核服务例程以处理系统调用所请求的服务。

用户程序试图执行非法指令（特权或不存在的指令），或访问禁止的内存区域，还会生成软件中断，这些中断将被中断处理程序捕获，并将控制权转移到 OS，它将发出适当的错误消息，可能将数据转储到日志（核心）文件中以供以后分析，然后终止有问题的程序。

**什么是微内核？**

微内核是内核的分类之一。作为内核，它可以管理所有系统资源。但是在微内核中，**用户服务**和**内核服务**是在不同的地址空间中实现的。用户服务保存在用户地址空间中，内核服务保存在内核地址空间中，因此也减少了内核的大小和操作系统的大小。

![https://media.geeksforgeeks.org/wp-content/uploads/Microkernel.jpeg](../.resource/Computer/Operating%20Systems/Microkernel.jpeg)

它提供最少的进程和内存管理服务。客户端程序/应用程序与在用户地址空间中运行的服务之间的通信是通过消息传递建立的，降低了微内核的执行速度。由于用户服务和内核服务是隔离的，因此操作系统不会受到影响，因此，如果任何用户服务失败，则不会影响内核服务。因此，它增加了微内核的优点之一。它很容易扩展，即如果要添加任何新服务，则将它们添加到用户地址空间，因此不需要修改内核空间。它也是便携式的，安全的和可靠的。

**微内核架构**

由于内核是操作系统的核心部分，因此它仅用于处理最重要的服务。因此，在此体系结构中，只有最重要的服务位于内核内部，而其余 OS 服务则位于系统应用程序内部。因此，用户能够与系统应用程序中那些不太重要的服务进行交互。微内核仅负责操作系统最重要的服务，它们的名称如下：

- 进程间通信
- 内存管理
- CPU 调度

**微内核的优势**

- 该内核的体系结构较小且隔离，因此可以更好地运行。
- 系统的扩展比较容易，只需将其添加到系统应用程序中即可，而不会干扰内核。

Eclipse IDE 是微内核架构的一个很好的例子。

## 操作系统中的内核 I/O 子系统

先决条件–微内核

内核提供了许多与 I/O 相关的服务。内核的基于硬件和设备驱动程序基础结构的 I/O 子系统提供了诸如调度，缓存，后台处理，设备保留和错误处理之类的多种服务。I/O 子系统还负责保护自己免受错误进程和恶意用户的侵害。

1. I/O 调度

    计划一组 I/O 请求意味着确定执行它们的良好顺序。最佳选择是应用程序发出系统调用的顺序。调度可以改善系统的整体性能，可以公平地向所有进程共享设备访问权限，减少平均等待时间，响应时间，I/O 完成的周转时间。

    OS 开发人员通过为每个设备维护请求的等待队列来实现调度。当应用程序发出阻塞的 I/O 系统调用时，该请求将放置在该设备的队列中。I/O 调度程序重新排列顺序以提高系统效率。

2. 缓冲

    缓冲区是一个存储区域，用于存储在两个设备之间或一个设备与应用程序之间传输的数据。进行缓冲有三个原因。

    1. 首先是要应对数据流的生产者和使用者之间的速度不匹配。
    2. 缓冲的第二种用途是为具有不同数据传输大小的数据提供适配。
    3. 缓冲的第三种用途是为应用程序 I/O 支持复制语义。“复制语义” 是指，假设应用程序要在存储在其缓冲区中的磁盘上写入数据。它调用 write() 系统调用，提供指向缓冲区的指针，整数指定要写入的字节数。

    系统调用返回后，如果缓冲区的应用程序更改了缓冲区的内容会怎样？使用复制语义，可以保证写入磁盘的数据版本是应用程序系统调用时的版本。

3. 缓存

    缓存是快速存储器的一个区域，用于保存数据副本。访问缓存副本比原始文件容易得多。例如，当前正在运行的进程的指令存储在磁盘上，缓存在物理内存中，然后再次复制到 CPU 的二级和一级缓存中。

    缓冲区与缓存之间的主要区别在于，缓冲区仅可以保留数据项的现有副本，而根据定义，缓存可以在其他地方更快地存储项时保留副本。

4. 假脱机和设备预留

    假脱机程序是一个缓冲区，用于保存设备的输出，例如不能接受交错数据流的打印机。尽管一台打印机一次只能完成一项工作，但有些应用程序可能希望同时打印其输出，而又不能将它们的输出混合在一起。操作系统通过阻止所有输出继续输出到打印机来解决此问题。所有应用程序的输出都后台处理在单独的磁盘文件中。当应用程序完成打印时，假脱机系统会将相应的假脱机文件排入队列，以输出到打印机。

5. 错误处理

    使用受保护的内存的操作系统可以防范多种硬件和应用程序错误，因此，每次出现轻微机械故障时，通常不会导致系统完全故障，设备和 I/O 传输可能会以多种方式失败，可能是由于暂时原因（例如网络过载时），也可能是由于永久性原因（例如磁盘控制器出现故障）。

6. I/O 保护

    错误和保护问题密切相关。用户进程可能试图发出非法的 I/O 指令来破坏系统的正常功能。我们可以使用各种机制来确保此类中断不会在系统中发生。 为了防止非法 I/O 访问，我们将所有 I/O 指令都定义为特权指令。用户不能直接发出 I/O 指令。

## 整体内核和与微内核的主要区别

除微内核外，整体内核是内核的另一种分类。像微内核一样，它也管理应用程序和硬件之间的系统资源，但是用户服务和内核服务是在相同的地址空间下实现的。它增加了内核的大小，因此也增加了操作系统的大小。

该内核通过系统调用提供 CPU 调度，内存管理，文件管理和其他操作系统功能。由于两个服务都是在相同的地址空间下实现的，因此可以更快地执行操作系统。 下面是整体内核的示意图：

![https://media.geeksforgeeks.org/wp-content/uploads/monolithic_kernel.jpeg](../.resource/Computer/Operating%20Systems/monolithic_kernel.jpeg)

如果任何服务失败，整个系统将崩溃，这是此内核的缺点之一。如果用户添加新服务，则需要修改整个操作系统。

**整体内核的优势**

- 具有单片内核的主要优点之一是它通过系统调用提供 CPU 调度，内存管理，文件管理和其他操作系统功能。
- 另一个是它是一个完全在单个地址空间中运行的单个大型进程。
- 它是一个静态二进制文件。一些基于单片内核的 OS 的示例是：Unix，Linux，Open VMS，XTS-400，z/TPF。

**整体内核的缺点**

- 单片内核的主要缺点之一是，如果任何服务失败，则会导致整个系统失败。
- 如果用户必须添加任何新服务。用户需要修改整个操作系统。

**整体内核和微内核之间的主要区别**

![https://media.geeksforgeeks.org/wp-content/uploads/Difference.jpeg](../.resource/Computer/Operating%20Systems/Difference.jpeg)

## 系统调用介绍

在计算中，系统调用是一种编程方式，计算机程序从该程序中向执行其的操作系统内核请求服务。系统调用是程序与操作系统进行交互的一种方式。计算机程序向操作系统的内核发出请求时会进行系统调用。系统调用通过应用程序接口（API）向用户程序提供操作系统的服务。它在进程和操作系统之间提供接口，以允许用户级进程请求操作系统的服务。系统调用是进入内核系统的唯一入口点。所有需要资源的程序都必须使用系统调用。

**系统调用提供的服务：**

1. 创建进程和管理
2. 主内存管理
3. 文件访问，目录和文件系统管理
4. 设备处理（I/O）
5. 保护
6. 网络...

**系统调用的类型**

1. 进程控制：结束，中止，创建，终止，分配和释放内存。
2. 文件管理：创建，打开，关闭，删除，读取文件等。
3. 设备管理
4. 信息维护
5. 通信

**Windows 和 Unix 系统调用的示例**

 ` `|WINDOWS|UNIX
 :---|:---|:---
 Process Control|CreateProcess()<br>ExitProcess()<br>WaitForSingleObject()|fork()<br>exit()<br>wait()
 File Manipulation|CreateFile()<br>ReadFile()<br>WriteFile()<br>CloseHandle()|open()<br>read()<br>write()<br>close()
 Device Manipulation|SetConsoleMode()<br>ReadConsole()<br>WriteConsole()|ioctl()<br>read()<br>write()
 Information Maintenance|GetCurrentProcessID()<br>SetTimer()<br>Sleep()|getpid()<br>alarm()<br>sleep()
 Communication|CreatePipe()<br>CreateFileMapping()<br>MapViewOfFile()|pipe()<br>shmget()<br>mmap()
 Protection|SetFileSecurity()<br>InitlializeSecurityDescriptor()<br>SetSecurityDescriptorGroup()|chmod()<br>umask()<br>chown()